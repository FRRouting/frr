/**Testsrcdesttableforcorrectness.**Copyright(C)2017byDavidLamparter&ChristianFr
anke,*OpenSourceRouting/NetDEFInc.**ThisfileispartofFreeRangeRouting(FRR)**FRRis
freesoftware;youcanredistributeitand/ormodifyit*underthetermsoftheGNUGeneralPubl
icLicenseaspublishedbythe*FreeSoftwareFoundation;eitherversion2,or(atyouroption)
any*laterversion.**FRRisdistributedinthehopethatitwillbeuseful,but*WITHOUTANYWAR
RANTY;withouteventheimpliedwarrantyof*MERCHANTABILITYorFITNESSFORAPARTICULARPURP
OSE.SeetheGNU*GeneralPublicLicenseformoredetails.**Youshouldhavereceivedacopyoft
heGNUGeneralPublicLicensealong*withthisprogram;seethefileCOPYING;ifnot,writetoth
eFreeSoftware*Foundation,Inc.,51FranklinSt,FifthFloor,Boston,MA02110-1301USA*/#i
nclude<zebra.h>#include"hash.h"#include"memory.h"#include"prefix.h"#include"prng
.h"#include"srcdest_table.h"#include"table.h"/*Copiedfromripngd/ripng_nexthop.h-
maybethewholes6_addr32thing*shouldbeaddedbyautoconfifnotpresent?*/#ifndefs6_addr
32#ifdefined(SUNOS_5)/*SomeSunOSdefines6_addr32onlytokernel*/#defines6_addr32_S6
_un._S6_u32#else#defines6_addr32__u6_addr.__u6_addr32#endif/*SUNOS_5*/#endif/*s6
_addr32*/structthread_master*master;/*Thisstructureiscopiedfromlib/srcdest_table
.ctowhichitis*privateasfarasotherpartsofQuaggaareconcerned.*/structsrcdest_rnode
{/*mustbefirstinstructureforcastingto/fromroute_node*/ROUTE_NODE_FIELDS;structro
ute_table*src_table;};structtest_state{structroute_table*table;structhash*log;};
staticchar*format_srcdest(conststructprefix_ipv6*dst_p,conststructprefix_ipv6*sr
c_p){chardst_str[BUFSIZ];charsrc_str[BUFSIZ];char*rv;intec;prefix2str((conststru
ctprefix*)dst_p,dst_str,sizeof(dst_str));if(src_p&&src_p->prefixlen)prefix2str((
conststructprefix*)src_p,src_str,sizeof(src_str));elsesrc_str[0]='\0';ec=asprint
f(&rv,"%s%s%s",dst_str,(src_str[0]!='\0')?"from":"",src_str);assert(ec>0);return
rv;}staticunsignedintlog_key(void*data){structprefix*hash_entry=data;structprefi
x_ipv6*dst_p=(structprefix_ipv6*)&hash_entry[0];structprefix_ipv6*src_p=(structp
refix_ipv6*)&hash_entry[1];unsignedinthash=0;unsignedinti;hash=(hash*33)^(unsign
edint)dst_p->prefixlen;for(i=0;i<4;i++)hash=(hash*33)^(unsignedint)dst_p->prefix
.s6_addr32[i];hash=(hash*33)^(unsignedint)src_p->prefixlen;if(src_p->prefixlen)f
or(i=0;i<4;i++)hash=(hash*33)^(unsignedint)src_p->prefix.s6_addr32[i];returnhash
;}staticintlog_cmp(constvoid*a,constvoid*b){if(a==NULL&&b!=NULL)return0;if(b==NU
LL&&a!=NULL)return0;return!memcmp(a,b,2*sizeof(structprefix));}staticvoidlog_fre
e(void*data){XFREE(MTYPE_TMP,data);}staticvoid*log_alloc(void*data){void*rv=XMAL
LOC(MTYPE_TMP,2*sizeof(structprefix));memcpy(rv,data,2*sizeof(structprefix));ret
urnrv;}staticstructtest_state*test_state_new(void){structtest_state*rv;rv=XCALLO
C(MTYPE_TMP,sizeof(*rv));assert(rv);rv->table=srcdest_table_init();assert(rv->ta
ble);rv->log=hash_create(log_key,log_cmp,NULL);returnrv;}staticvoidtest_state_fr
ee(structtest_state*test){route_table_finish(test->table);hash_clean(test->log,l
og_free);hash_free(test->log);XFREE(MTYPE_TMP,test);}staticvoidtest_state_add_ro
ute(structtest_state*test,structprefix_ipv6*dst_p,structprefix_ipv6*src_p){struc
troute_node*rn=srcdest_rnode_get(test->table,(structprefix*)dst_p,src_p);structp
refixhash_entry[2];memset(hash_entry,0,sizeof(hash_entry));memcpy(&hash_entry[0]
,dst_p,sizeof(*dst_p));memcpy(&hash_entry[1],src_p,sizeof(*src_p));if(rn->info){
route_unlock_node(rn);assert(hash_lookup(test->log,hash_entry)!=NULL);return;}el
se{assert(hash_lookup(test->log,hash_entry)==NULL);}rn->info=(void*)0xdeadbeef;h
ash_get(test->log,hash_entry,log_alloc);};staticvoidtest_state_del_route(structt
est_state*test,structprefix_ipv6*dst_p,structprefix_ipv6*src_p){structroute_node
*rn=srcdest_rnode_lookup(test->table,(structprefix*)dst_p,src_p);structprefixhas
h_entry[2];memset(hash_entry,0,sizeof(hash_entry));memcpy(&hash_entry[0],dst_p,s
izeof(*dst_p));memcpy(&hash_entry[1],src_p,sizeof(*src_p));if(!rn){assert(!hash_
lookup(test->log,hash_entry));return;}assert(rn->info==(void*)0xdeadbeef);rn->in
fo=NULL;route_unlock_node(rn);route_unlock_node(rn);structprefix*hash_entry_inte
rn=hash_release(test->log,hash_entry);assert(hash_entry_intern!=NULL);XFREE(MTYP
E_TMP,hash_entry_intern);}staticvoidverify_log(structhash_backet*backet,void*arg
){structtest_state*test=arg;structprefix*hash_entry=backet->data;structprefix*ds
t_p=&hash_entry[0];structprefix_ipv6*src_p=(structprefix_ipv6*)&hash_entry[1];st
ructroute_node*rn=srcdest_rnode_lookup(test->table,dst_p,src_p);assert(rn);asser
t(rn->info==(void*)0xdeadbeef);route_unlock_node(rn);}staticvoiddump_log(structh
ash_backet*backet,void*arg){structprefix*hash_entry=backet->data;structprefix_ip
v6*dst_p=(structprefix_ipv6*)&hash_entry[0];structprefix_ipv6*src_p=(structprefi
x_ipv6*)&hash_entry[1];char*route_id=format_srcdest(dst_p,src_p);fprintf(stderr,
"%s\n",route_id);free(route_id);}staticvoidtest_dump(structtest_state*test){fpri
ntf(stderr,"Contentsofhashtable:\n");hash_iterate(test->log,dump_log,test);fprin
tf(stderr,"\n");}staticvoidtest_failed(structtest_state*test,constchar*message,s
tructprefix_ipv6*dst_p,structprefix_ipv6*src_p){char*route_id=format_srcdest(dst
_p,src_p);fprintf(stderr,"Testfailed.Error:%s\n",message);fprintf(stderr,"Routei
nquestion:%s\n",route_id);free(route_id);test_dump(test);assert(3==4);}staticvoi
dtest_state_verify(structtest_state*test){structroute_node*rn;structprefixhash_e
ntry[2];memset(hash_entry,0,sizeof(hash_entry));/*Verifythattherearenoelementsin
thetablewhichhavenever*beenadded*/for(rn=route_top(test->table);rn;rn=srcdest_ro
ute_next(rn)){structprefix_ipv6*dst_p,*src_p;/*Whileweareiterating,weholdalockon
thecurrent*route_node,*soallthelockcountswecheckfortakethatintoaccount;*inidle*s
tateallthenumberswillbeexactlyoneless.**Alsothismakesquitesomeassumptionsbasedon
thecurrent*implementationdetailsofroute_tableandsrcdest_table-*another*validimpl
ementationmighttriggerassertionshere.*/if(rnode_is_dstnode(rn)){structsrcdest_rn
ode*srn=(structsrcdest_rnode*)rn;unsignedintexpected_lock=1;/*Weareintheloop*/if
(rn->info!=NULL)/*Theroutenodeisnotinternal*/expected_lock++;if(srn->src_table!=
NULL)/*There'sasourcetableassociatedwithrn*/expected_lock++;if(rn->lock!=expecte
d_lock)test_failed(test,"Destrnodelockcountdoesn'tmatchexpectedcount!",(structpr
efix_ipv6*)&rn->p,NULL);}else{unsignedintexpected_lock=1;/*Weareintheloop*/if(rn
->info!=NULL)/*Theroutenodeisnotinternal*/expected_lock++;if(rn->lock!=expected_
lock){structprefix_ipv6*dst_p,*src_p;srcdest_rnode_prefixes(rn,(structprefix**)&
dst_p,(structprefix**)&src_p);test_failed(test,"Srcrnodelockcountdoesn'tmatchexp
ectedcount!",dst_p,src_p);}}if(!rn->info)continue;assert(rn->info==(void*)0xdead
beef);srcdest_rnode_prefixes(rn,(structprefix**)&dst_p,(structprefix**)&src_p);m
emcpy(&hash_entry[0],dst_p,sizeof(*dst_p));if(src_p)memcpy(&hash_entry[1],src_p,
sizeof(*src_p));elsememset(&hash_entry[1],0,sizeof(hash_entry[1]));if(hash_looku
p(test->log,hash_entry)==NULL)test_failed(test,"Routeismissinginhash",dst_p,src_
p);}/*Verifythatalladdedelementsarestillinthetable*/hash_iterate(test->log,verif
y_log,test);}staticvoidget_rand_prefix(structprng*prng,structprefix_ipv6*p){inti
;memset(p,0,sizeof(*p));for(i=0;i<4;i++)p->prefix.s6_addr32[i]=prng_rand(prng);p
->prefixlen=prng_rand(prng)%129;p->family=AF_INET6;apply_mask((structprefix*)p);
}staticvoidget_rand_prefix_pair(structprng*prng,structprefix_ipv6*dst_p,structpr
efix_ipv6*src_p){get_rand_prefix(prng,dst_p);if((prng_rand(prng)%4)==0){get_rand
_prefix(prng,src_p);if(src_p->prefixlen)return;}memset(src_p,0,sizeof(*src_p));}
staticvoidtest_state_add_rand_route(structtest_state*test,structprng*prng){struc
tprefix_ipv6dst_p,src_p;get_rand_prefix_pair(prng,&dst_p,&src_p);test_state_add_
route(test,&dst_p,&src_p);}staticvoidtest_state_del_rand_route(structtest_state*
test,structprng*prng){structprefix_ipv6dst_p,src_p;get_rand_prefix_pair(prng,&ds
t_p,&src_p);test_state_del_route(test,&dst_p,&src_p);}staticvoidtest_state_del_o
ne_route(structtest_state*test,structprng*prng){unsignedintwhich_route;if(test->
log->count==0)return;which_route=prng_rand(prng)%test->log->count;structroute_no
de*rn;structprefix*dst_p,*src_p;structprefix_ipv6dst6_p,src6_p;for(rn=route_top(
test->table);rn;rn=srcdest_route_next(rn)){if(!rn->info)continue;if(!which_route
){route_unlock_node(rn);break;}which_route--;}assert(rn);srcdest_rnode_prefixes(
rn,&dst_p,&src_p);memcpy(&dst6_p,dst_p,sizeof(dst6_p));if(src_p)memcpy(&src6_p,s
rc_p,sizeof(src6_p));elsememset(&src6_p,0,sizeof(src6_p));test_state_del_route(t
est,&dst6_p,&src6_p);}staticvoidrun_prng_test(void){structtest_state*test=test_s
tate_new();structprng*prng=prng_new(0);size_ti;for(i=0;i<1000;i++){switch(prng_r
and(prng)%10){case0:case1:case2:case3:case4:test_state_add_rand_route(test,prng)
;break;case5:case6:case7:test_state_del_one_route(test,prng);break;case8:case9:t
est_state_del_rand_route(test,prng);break;}test_state_verify(test);}prng_free(pr
ng);test_state_free(test);}intmain(intargc,char*argv[]){run_prng_test();printf("
PRNGTestsuccessful.\n");return0;}