/*$OpenBSD:queue.h,v1.432015/12/2819:38:40millertExp$*//*$NetBSD:queue.h,v1.1119
96/05/1605:17:14mycroftExp$*//**Copyright(c)1991,1993*TheRegentsoftheUniversityo
fCalifornia.Allrightsreserved.**Redistributionanduseinsourceandbinaryforms,witho
rwithout*modification,arepermittedprovidedthatthefollowingconditions*aremet:*1.R
edistributionsofsourcecodemustretaintheabovecopyright*notice,thislistofcondition
sandthefollowingdisclaimer.*2.Redistributionsinbinaryformmustreproducetheaboveco
pyright*notice,thislistofconditionsandthefollowingdisclaimerinthe*documentationa
nd/orothermaterialsprovidedwiththedistribution.*3.NeitherthenameoftheUniversityn
orthenamesofitscontributors*maybeusedtoendorseorpromoteproductsderivedfromthisso
ftware*withoutspecificpriorwrittenpermission.**THISSOFTWAREISPROVIDEDBYTHEREGENT
SANDCONTRIBUTORS``ASIS''AND*ANYEXPRESSORIMPLIEDWARRANTIES,INCLUDING,BUTNOTLIMITE
DTO,THE*IMPLIEDWARRANTIESOFMERCHANTABILITYANDFITNESSFORAPARTICULARPURPOSE*AREDIS
CLAIMED.INNOEVENTSHALLTHEREGENTSORCONTRIBUTORSBELIABLE*FORANYDIRECT,INDIRECT,INC
IDENTAL,SPECIAL,EXEMPLARY,ORCONSEQUENTIAL*DAMAGES(INCLUDING,BUTNOTLIMITEDTO,PROC
UREMENTOFSUBSTITUTEGOODS*ORSERVICES;LOSSOFUSE,DATA,ORPROFITS;ORBUSINESSINTERRUPT
ION)*HOWEVERCAUSEDANDONANYTHEORYOFLIABILITY,WHETHERINCONTRACT,STRICT*LIABILITY,O
RTORT(INCLUDINGNEGLIGENCEOROTHERWISE)ARISINGINANYWAY*OUTOFTHEUSEOFTHISSOFTWARE,E
VENIFADVISEDOFTHEPOSSIBILITYOF*SUCHDAMAGE.**@(#)queue.h8.5(Berkeley)8/20/94*/#if
ndef_SYS_QUEUE_H_#define_SYS_QUEUE_H_/**Thisfiledefinesfivetypesofdatastructures
:singly-linkedlists,*lists,simplequeues,tailqueuesandXORsimplequeues.***Asingly-
linkedlistisheadedbyasingleforwardpointer.Theelements*aresinglylinkedforminimums
paceandpointermanipulationoverheadat*theexpenseofO(n)removalforarbitraryelements
.Newelementscanbe*addedtothelistafteranexistingelementorattheheadofthelist.*Elem
entsbeingremovedfromtheheadofthelistshouldusetheexplicit*macroforthispurposeforo
ptimumefficiency.Asingly-linkedlistmay*onlybetraversedintheforwarddirection.Sing
ly-linkedlistsareideal*forapplicationswithlargedatasetsandfewornoremovalsorfor*i
mplementingaLIFOqueue.**Alistisheadedbyasingleforwardpointer(oranarrayofforward*
pointersforahashtableheader).Theelementsaredoublylinked*sothatanarbitraryelement
canberemovedwithoutaneedto*traversethelist.Newelementscanbeaddedtothelistbefore*
orafteranexistingelementorattheheadofthelist.Alist*mayonlybetraversedintheforwar
ddirection.**Asimplequeueisheadedbyapairofpointers,onetotheheadofthe*listandtheo
thertothetailofthelist.Theelementsaresingly*linkedtosavespace,soelementscanonlyb
eremovedfromthe*headofthelist.Newelementscanbeaddedtothelistbeforeorafter*anexis
tingelement,attheheadofthelist,orattheendofthe*list.Asimplequeuemayonlybetravers
edintheforwarddirection.**Atailqueueisheadedbyapairofpointers,onetotheheadofthe*
listandtheothertothetailofthelist.Theelementsaredoubly*linkedsothatanarbitraryel
ementcanberemovedwithoutaneedto*traversethelist.Newelementscanbeaddedtothelistbe
foreor*afteranexistingelement,attheheadofthelist,orattheendof*thelist.Atailqueue
maybetraversedineitherdirection.**AnXORsimplequeueisusedinthesamewayasaregularsi
mplequeue.*Thedifferenceisthattheheadstructurealsoincludesa"cookie"that*isXOR'dw
iththequeuepointer(first,lastornext)togeneratethe*realpointervalue.**Fordetailso
ntheuseofthesemacros,seethequeue(3)manualpage.*/#ifdefined(QUEUE_MACRO_DEBUG)||(
defined(_KERNEL)&&defined(DIAGNOSTIC))#define_Q_INVALIDATE(a)(a)=((void*)-1)#els
e#define_Q_INVALIDATE(a)#endif/**Singly-linkedListdefinitions.*/#defineSLIST_HEA
D(name,type)\structname{\structtype*slh_first;/*firstelement*/\}#defineSLIST_HEA
D_INITIALIZER(head)\{\NULL\}#defineSLIST_ENTRY(type)\struct{\structtype*sle_next
;/*nextelement*/\}/**Singly-linkedListaccessmethods.*/#defineSLIST_FIRST(head)((
head)->slh_first)#defineSLIST_END(head)NULL#defineSLIST_EMPTY(head)(SLIST_FIRST(
head)==SLIST_END(head))#defineSLIST_NEXT(elm,field)((elm)->field.sle_next)#defin
eSLIST_FOREACH(var,head,field)\for((var)=SLIST_FIRST(head);(var)!=SLIST_END(head
);\(var)=SLIST_NEXT(var,field))#defineSLIST_FOREACH_SAFE(var,head,field,tvar)\fo
r((var)=SLIST_FIRST(head);\(var)&&((tvar)=SLIST_NEXT(var,field),1);(var)=(tvar))
/**Singly-linkedListfunctions.*/#defineSLIST_INIT(head)\{\SLIST_FIRST(head)=SLIS
T_END(head);\}#defineSLIST_INSERT_AFTER(slistelm,elm,field)\do{\(elm)->field.sle
_next=(slistelm)->field.sle_next;\(slistelm)->field.sle_next=(elm);\}while(0)#de
fineSLIST_INSERT_HEAD(head,elm,field)\do{\(elm)->field.sle_next=(head)->slh_firs
t;\(head)->slh_first=(elm);\}while(0)#defineSLIST_REMOVE_AFTER(elm,field)\do{\(e
lm)->field.sle_next=(elm)->field.sle_next->field.sle_next;\}while(0)#defineSLIST
_REMOVE_HEAD(head,field)\do{\(head)->slh_first=(head)->slh_first->field.sle_next
;\}while(0)#defineSLIST_REMOVE(head,elm,type,field)\do{\if((head)->slh_first==(e
lm)){\SLIST_REMOVE_HEAD((head),field);\}else{\structtype*curelm=(head)->slh_firs
t;\\while(curelm->field.sle_next!=(elm))\curelm=curelm->field.sle_next;\curelm->
field.sle_next=\curelm->field.sle_next->field.sle_next;\}\_Q_INVALIDATE((elm)->f
ield.sle_next);\}while(0)/**Listdefinitions.*/#defineLIST_HEAD(name,type)\struct
name{\structtype*lh_first;/*firstelement*/\}#defineLIST_HEAD_INITIALIZER(head)\{
\NULL\}#defineLIST_ENTRY(type)\struct{\structtype*le_next;/*nextelement*/\struct
type**le_prev;/*addressofpreviousnextelement*/\}/**Listaccessmethods.*/#defineLI
ST_FIRST(head)((head)->lh_first)#defineLIST_END(head)NULL#defineLIST_EMPTY(head)
(LIST_FIRST(head)==LIST_END(head))#defineLIST_NEXT(elm,field)((elm)->field.le_ne
xt)#defineLIST_FOREACH(var,head,field)\for((var)=LIST_FIRST(head);(var)!=LIST_EN
D(head);\(var)=LIST_NEXT(var,field))#defineLIST_FOREACH_SAFE(var,head,field,tvar
)\for((var)=LIST_FIRST(head);\(var)&&((tvar)=LIST_NEXT(var,field),1);(var)=(tvar
))/**Listfunctions.*/#defineLIST_INIT(head)\do{\LIST_FIRST(head)=LIST_END(head);
\}while(0)#defineLIST_INSERT_AFTER(listelm,elm,field)\do{\if(((elm)->field.le_ne
xt=(listelm)->field.le_next)!=NULL)\(listelm)->field.le_next->field.le_prev=\&(e
lm)->field.le_next;\(listelm)->field.le_next=(elm);\(elm)->field.le_prev=&(liste
lm)->field.le_next;\}while(0)#defineLIST_INSERT_BEFORE(listelm,elm,field)\do{\(e
lm)->field.le_prev=(listelm)->field.le_prev;\(elm)->field.le_next=(listelm);\*(l
istelm)->field.le_prev=(elm);\(listelm)->field.le_prev=&(elm)->field.le_next;\}w
hile(0)#defineLIST_INSERT_HEAD(head,elm,field)\do{\if(((elm)->field.le_next=(hea
d)->lh_first)!=NULL)\(head)->lh_first->field.le_prev=\&(elm)->field.le_next;\(he
ad)->lh_first=(elm);\(elm)->field.le_prev=&(head)->lh_first;\}while(0)#defineLIS
T_REMOVE(elm,field)\do{\if((elm)->field.le_next!=NULL)\(elm)->field.le_next->fie
ld.le_prev=\(elm)->field.le_prev;\*(elm)->field.le_prev=(elm)->field.le_next;\_Q
_INVALIDATE((elm)->field.le_prev);\_Q_INVALIDATE((elm)->field.le_next);\}while(0
)#defineLIST_REPLACE(elm,elm2,field)\do{\if(((elm2)->field.le_next=(elm)->field.
le_next)!=NULL)\(elm2)->field.le_next->field.le_prev=\&(elm2)->field.le_next;\(e
lm2)->field.le_prev=(elm)->field.le_prev;\*(elm2)->field.le_prev=(elm2);\_Q_INVA
LIDATE((elm)->field.le_prev);\_Q_INVALIDATE((elm)->field.le_next);\}while(0)/**S
implequeuedefinitions.*/#defineSIMPLEQ_HEAD(name,type)\structname{\structtype*sq
h_first;/*firstelement*/\structtype**sqh_last;/*addroflastnextelement*/\}#define
SIMPLEQ_HEAD_INITIALIZER(head)\{\NULL,&(head).sqh_first\}#defineSIMPLEQ_ENTRY(ty
pe)\struct{\structtype*sqe_next;/*nextelement*/\}/**Simplequeueaccessmethods.*/#
defineSIMPLEQ_FIRST(head)((head)->sqh_first)#defineSIMPLEQ_END(head)NULL#defineS
IMPLEQ_EMPTY(head)(SIMPLEQ_FIRST(head)==SIMPLEQ_END(head))#defineSIMPLEQ_NEXT(el
m,field)((elm)->field.sqe_next)#defineSIMPLEQ_FOREACH(var,head,field)\for((var)=
SIMPLEQ_FIRST(head);(var)!=SIMPLEQ_END(head);\(var)=SIMPLEQ_NEXT(var,field))#def
ineSIMPLEQ_FOREACH_SAFE(var,head,field,tvar)\for((var)=SIMPLEQ_FIRST(head);\(var
)&&((tvar)=SIMPLEQ_NEXT(var,field),1);(var)=(tvar))/**Simplequeuefunctions.*/#de
fineSIMPLEQ_INIT(head)\do{\(head)->sqh_first=NULL;\(head)->sqh_last=&(head)->sqh
_first;\}while(0)#defineSIMPLEQ_INSERT_HEAD(head,elm,field)\do{\if(((elm)->field
.sqe_next=(head)->sqh_first)==NULL)\(head)->sqh_last=&(elm)->field.sqe_next;\(he
ad)->sqh_first=(elm);\}while(0)#defineSIMPLEQ_INSERT_TAIL(head,elm,field)\do{\(e
lm)->field.sqe_next=NULL;\*(head)->sqh_last=(elm);\(head)->sqh_last=&(elm)->fiel
d.sqe_next;\}while(0)#defineSIMPLEQ_INSERT_AFTER(head,listelm,elm,field)\do{\if(
((elm)->field.sqe_next=(listelm)->field.sqe_next)\==NULL)\(head)->sqh_last=&(elm
)->field.sqe_next;\(listelm)->field.sqe_next=(elm);\}while(0)#defineSIMPLEQ_REMO
VE_HEAD(head,field)\do{\if(((head)->sqh_first=(head)->sqh_first->field.sqe_next)
\==NULL)\(head)->sqh_last=&(head)->sqh_first;\}while(0)#defineSIMPLEQ_REMOVE_AFT
ER(head,elm,field)\do{\if(((elm)->field.sqe_next=\(elm)->field.sqe_next->field.s
qe_next)\==NULL)\(head)->sqh_last=&(elm)->field.sqe_next;\}while(0)#defineSIMPLE
Q_CONCAT(head1,head2)\do{\if(!SIMPLEQ_EMPTY((head2))){\*(head1)->sqh_last=(head2
)->sqh_first;\(head1)->sqh_last=(head2)->sqh_last;\SIMPLEQ_INIT((head2));\}\}whi
le(0)/**XORSimplequeuedefinitions.*/#defineXSIMPLEQ_HEAD(name,type)\structname{\
structtype*sqx_first;/*firstelement*/\structtype**sqx_last;/*addroflastnexteleme
nt*/\unsignedlongsqx_cookie;\}#defineXSIMPLEQ_ENTRY(type)\struct{\structtype*sqx
_next;/*nextelement*/\}/**XORSimplequeueaccessmethods.*/#defineXSIMPLEQ_XOR(head
,ptr)\((__typeof(ptr))((head)->sqx_cookie^(unsignedlong)(ptr)))#defineXSIMPLEQ_F
IRST(head)XSIMPLEQ_XOR(head,((head)->sqx_first))#defineXSIMPLEQ_END(head)NULL#de
fineXSIMPLEQ_EMPTY(head)(XSIMPLEQ_FIRST(head)==XSIMPLEQ_END(head))#defineXSIMPLE
Q_NEXT(head,elm,field)XSIMPLEQ_XOR(head,((elm)->field.sqx_next))#defineXSIMPLEQ_
FOREACH(var,head,field)\for((var)=XSIMPLEQ_FIRST(head);(var)!=XSIMPLEQ_END(head)
;\(var)=XSIMPLEQ_NEXT(head,var,field))#defineXSIMPLEQ_FOREACH_SAFE(var,head,fiel
d,tvar)\for((var)=XSIMPLEQ_FIRST(head);\(var)&&((tvar)=XSIMPLEQ_NEXT(head,var,fi
eld),1);\(var)=(tvar))/**XORSimplequeuefunctions.*/#defineXSIMPLEQ_INIT(head)\do
{\arc4random_buf(&(head)->sqx_cookie,\sizeof((head)->sqx_cookie));\(head)->sqx_f
irst=XSIMPLEQ_XOR(head,NULL);\(head)->sqx_last=XSIMPLEQ_XOR(head,&(head)->sqx_fi
rst);\}while(0)#defineXSIMPLEQ_INSERT_HEAD(head,elm,field)\do{\if(((elm)->field.
sqx_next=(head)->sqx_first)\==XSIMPLEQ_XOR(head,NULL))\(head)->sqx_last=\XSIMPLE
Q_XOR(head,&(elm)->field.sqx_next);\(head)->sqx_first=XSIMPLEQ_XOR(head,(elm));\
}while(0)#defineXSIMPLEQ_INSERT_TAIL(head,elm,field)\do{\(elm)->field.sqx_next=X
SIMPLEQ_XOR(head,NULL);\*(XSIMPLEQ_XOR(head,(head)->sqx_last))=\XSIMPLEQ_XOR(hea
d,(elm));\(head)->sqx_last=XSIMPLEQ_XOR(head,&(elm)->field.sqx_next);\}while(0)#
defineXSIMPLEQ_INSERT_AFTER(head,listelm,elm,field)\do{\if(((elm)->field.sqx_nex
t=(listelm)->field.sqx_next)\==XSIMPLEQ_XOR(head,NULL))\(head)->sqx_last=\XSIMPL
EQ_XOR(head,&(elm)->field.sqx_next);\(listelm)->field.sqx_next=XSIMPLEQ_XOR(head
,(elm));\}while(0)#defineXSIMPLEQ_REMOVE_HEAD(head,field)\do{\if(((head)->sqx_fi
rst=XSIMPLEQ_XOR(head,(head)->sqx_first)\->field.sqx_next)\==XSIMPLEQ_XOR(head,N
ULL))\(head)->sqx_last=\XSIMPLEQ_XOR(head,&(head)->sqx_first);\}while(0)#defineX
SIMPLEQ_REMOVE_AFTER(head,elm,field)\do{\if(((elm)->field.sqx_next=\XSIMPLEQ_XOR
(head,(elm)->field.sqx_next)\->field.sqx_next)\==XSIMPLEQ_XOR(head,NULL))\(head)
->sqx_last=\XSIMPLEQ_XOR(head,&(elm)->field.sqx_next);\}while(0)/**Tailqueuedefi
nitions.*/#defineTAILQ_HEAD(name,type)\structname{\structtype*tqh_first;/*firste
lement*/\structtype**tqh_last;/*addroflastnextelement*/\}#defineTAILQ_HEAD_INITI
ALIZER(head)\{\NULL,&(head).tqh_first\}#defineTAILQ_ENTRY(type)\struct{\structty
pe*tqe_next;/*nextelement*/\structtype**tqe_prev;/*addressofpreviousnextelement*
/\}/**Tailqueueaccessmethods.*/#defineTAILQ_FIRST(head)((head)->tqh_first)#defin
eTAILQ_END(head)NULL#defineTAILQ_NEXT(elm,field)((elm)->field.tqe_next)#defineTA
ILQ_LAST(head,headname)\(*(((structheadname*)((head)->tqh_last))->tqh_last))/*XX
X*/#defineTAILQ_PREV(elm,headname,field)\(*(((structheadname*)((elm)->field.tqe_
prev))->tqh_last))#defineTAILQ_EMPTY(head)(TAILQ_FIRST(head)==TAILQ_END(head))#d
efineTAILQ_FOREACH(var,head,field)\for((var)=TAILQ_FIRST(head);(var)!=TAILQ_END(
head);\(var)=TAILQ_NEXT(var,field))#defineTAILQ_FOREACH_SAFE(var,head,field,tvar
)\for((var)=TAILQ_FIRST(head);\(var)!=TAILQ_END(head)&&((tvar)=TAILQ_NEXT(var,fi
eld),1);\(var)=(tvar))#defineTAILQ_FOREACH_REVERSE(var,head,headname,field)\for(
(var)=TAILQ_LAST(head,headname);(var)!=TAILQ_END(head);\(var)=TAILQ_PREV(var,hea
dname,field))#defineTAILQ_FOREACH_REVERSE_SAFE(var,head,headname,field,tvar)\for
((var)=TAILQ_LAST(head,headname);\(var)!=TAILQ_END(head)\&&((tvar)=TAILQ_PREV(va
r,headname,field),1);\(var)=(tvar))/**Tailqueuefunctions.*/#defineTAILQ_INIT(hea
d)\do{\(head)->tqh_first=NULL;\(head)->tqh_last=&(head)->tqh_first;\}while(0)#de
fineTAILQ_INSERT_HEAD(head,elm,field)\do{\if(((elm)->field.tqe_next=(head)->tqh_
first)!=NULL)\(head)->tqh_first->field.tqe_prev=\&(elm)->field.tqe_next;\else\(h
ead)->tqh_last=&(elm)->field.tqe_next;\(head)->tqh_first=(elm);\(elm)->field.tqe
_prev=&(head)->tqh_first;\}while(0)#defineTAILQ_INSERT_TAIL(head,elm,field)\do{\
(elm)->field.tqe_next=NULL;\(elm)->field.tqe_prev=(head)->tqh_last;\*(head)->tqh
_last=(elm);\(head)->tqh_last=&(elm)->field.tqe_next;\}while(0)#defineTAILQ_INSE
RT_AFTER(head,listelm,elm,field)\do{\if(((elm)->field.tqe_next=(listelm)->field.
tqe_next)\!=NULL)\(elm)->field.tqe_next->field.tqe_prev=\&(elm)->field.tqe_next;
\else\(head)->tqh_last=&(elm)->field.tqe_next;\(listelm)->field.tqe_next=(elm);\
(elm)->field.tqe_prev=&(listelm)->field.tqe_next;\}while(0)#defineTAILQ_INSERT_B
EFORE(listelm,elm,field)\do{\(elm)->field.tqe_prev=(listelm)->field.tqe_prev;\(e
lm)->field.tqe_next=(listelm);\*(listelm)->field.tqe_prev=(elm);\(listelm)->fiel
d.tqe_prev=&(elm)->field.tqe_next;\}while(0)#defineTAILQ_REMOVE(head,elm,field)\
do{\if(((elm)->field.tqe_next)!=NULL)\(elm)->field.tqe_next->field.tqe_prev=\(el
m)->field.tqe_prev;\else\(head)->tqh_last=(elm)->field.tqe_prev;\*(elm)->field.t
qe_prev=(elm)->field.tqe_next;\_Q_INVALIDATE((elm)->field.tqe_prev);\_Q_INVALIDA
TE((elm)->field.tqe_next);\}while(0)#defineTAILQ_REPLACE(head,elm,elm2,field)\do
{\if(((elm2)->field.tqe_next=(elm)->field.tqe_next)!=NULL)\(elm2)->field.tqe_nex
t->field.tqe_prev=\&(elm2)->field.tqe_next;\else\(head)->tqh_last=&(elm2)->field
.tqe_next;\(elm2)->field.tqe_prev=(elm)->field.tqe_prev;\*(elm2)->field.tqe_prev
=(elm2);\_Q_INVALIDATE((elm)->field.tqe_prev);\_Q_INVALIDATE((elm)->field.tqe_ne
xt);\}while(0)#defineTAILQ_CONCAT(head1,head2,field)\do{\if(!TAILQ_EMPTY(head2))
{\*(head1)->tqh_last=(head2)->tqh_first;\(head2)->tqh_first->field.tqe_prev=\(he
ad1)->tqh_last;\(head1)->tqh_last=(head2)->tqh_last;\TAILQ_INIT((head2));\}\}whi
le(0)#endif/*!_SYS_QUEUE_H_*/