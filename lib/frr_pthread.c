/**UtilitiesandinterfacesformanagingPOSIXthreadswithinFRR.*Copyright(C)2017Cumul
usNetworks,Inc.**Thisprogramisfreesoftware;youcanredistributeitand/ormodify*itun
derthetermsoftheGNUGeneralPublicLicenseaspublishedby*theFreeSoftwareFoundation;e
itherversion2oftheLicense,or*(atyouroption)anylaterversion.**Thisprogramisdistri
butedinthehopethatitwillbeuseful,but*WITHOUTANYWARRANTY;withouteventheimpliedwar
rantyof*MERCHANTABILITYorFITNESSFORAPARTICULARPURPOSE.SeetheGNU*GeneralPublicLic
enseformoredetails.**YoushouldhavereceivedacopyoftheGNUGeneralPublicLicensealong
*withthisprogram;seethefileCOPYING;ifnot,writetotheFreeSoftware*Foundation,Inc.,
51FranklinSt,FifthFloor,Boston,MA02110-1301USA*/#include<zebra.h>#include<pthrea
d.h>#include<sched.h>#include"frr_pthread.h"#include"memory.h"#include"hash.h"DE
FINE_MTYPE(LIB,FRR_PTHREAD,"FRRPOSIXThread");DEFINE_MTYPE(LIB,PTHREAD_PRIM,"POSI
Xsynchronizationprimitives");/*idfornextcreatedpthread*/static_Atomicuint32_tnex
t_id=0;/*defaultfrr_pthreadstart/stoproutineprototypes*/staticvoid*fpt_run(void*
arg);staticintfpt_halt(structfrr_pthread*fpt,void**res);/*defaultfrr_pthreadattr
ibutes*/structfrr_pthread_attrfrr_pthread_attr_default={.id=0,.start=fpt_run,.st
op=fpt_halt,};/*hashtabletokeeptrackofallfrr_pthreads*/staticstructhash*frr_pthr
ead_hash;staticpthread_mutex_tfrr_pthread_hash_mtx=PTHREAD_MUTEX_INITIALIZER;/*f
rr_pthread_hash->hash_cmp*/staticintfrr_pthread_hash_cmp(constvoid*value1,constv
oid*value2){conststructfrr_pthread*tq1=value1;conststructfrr_pthread*tq2=value2;
return(tq1->attr.id==tq2->attr.id);}/*frr_pthread_hash->hash_key*/staticunsigned
intfrr_pthread_hash_key(void*value){return((structfrr_pthread*)value)->attr.id;}
/*------------------------------------------------------------------------*/void
frr_pthread_init(){pthread_mutex_lock(&frr_pthread_hash_mtx);{frr_pthread_hash=h
ash_create(frr_pthread_hash_key,frr_pthread_hash_cmp,NULL);}pthread_mutex_unlock
(&frr_pthread_hash_mtx);}voidfrr_pthread_finish(){pthread_mutex_lock(&frr_pthrea
d_hash_mtx);{hash_clean(frr_pthread_hash,(void(*)(void*))frr_pthread_destroy);ha
sh_free(frr_pthread_hash);}pthread_mutex_unlock(&frr_pthread_hash_mtx);}structfr
r_pthread*frr_pthread_new(structfrr_pthread_attr*attr,constchar*name){staticstru
ctfrr_pthreadholder={};structfrr_pthread*fpt=NULL;attr=attr?attr:&frr_pthread_at
tr_default;pthread_mutex_lock(&frr_pthread_hash_mtx);{holder.attr.id=attr->id;if
(!hash_lookup(frr_pthread_hash,&holder)){fpt=XCALLOC(MTYPE_FRR_PTHREAD,sizeof(st
ructfrr_pthread));/*initializemutex*/pthread_mutex_init(&fpt->mtx,NULL);/*create
newthreadmaster*/fpt->master=thread_master_create(name);/*setattributes*/fpt->at
tr=*attr;name=(name?name:"Anonymousthread");fpt->name=XSTRDUP(MTYPE_FRR_PTHREAD,
name);if(attr==&frr_pthread_attr_default)fpt->attr.id=frr_pthread_get_id();/*ini
tializestartupsynchronizationprimitives*/fpt->running_cond_mtx=XCALLOC(MTYPE_PTH
READ_PRIM,sizeof(pthread_mutex_t));fpt->running_cond=XCALLOC(MTYPE_PTHREAD_PRIM,
sizeof(pthread_cond_t));pthread_mutex_init(fpt->running_cond_mtx,NULL);pthread_c
ond_init(fpt->running_cond,NULL);/*insertintoglobalthreadhash*/hash_get(frr_pthr
ead_hash,fpt,hash_alloc_intern);}}pthread_mutex_unlock(&frr_pthread_hash_mtx);re
turnfpt;}voidfrr_pthread_destroy(structfrr_pthread*fpt){thread_master_free(fpt->
master);pthread_mutex_destroy(&fpt->mtx);pthread_mutex_destroy(fpt->running_cond
_mtx);pthread_cond_destroy(fpt->running_cond);if(fpt->name)XFREE(MTYPE_FRR_PTHRE
AD,fpt->name);XFREE(MTYPE_PTHREAD_PRIM,fpt->running_cond_mtx);XFREE(MTYPE_PTHREA
D_PRIM,fpt->running_cond);XFREE(MTYPE_FRR_PTHREAD,fpt);}voidfrr_pthread_set_name
(structfrr_pthread*fpt,constchar*name){pthread_mutex_lock(&fpt->mtx);{if(fpt->na
me)XFREE(MTYPE_FRR_PTHREAD,fpt->name);fpt->name=XSTRDUP(MTYPE_FRR_PTHREAD,name);
}pthread_mutex_unlock(&fpt->mtx);thread_master_set_name(fpt->master,name);}struc
tfrr_pthread*frr_pthread_get(uint32_tid){staticstructfrr_pthreadholder={};struct
frr_pthread*fpt;pthread_mutex_lock(&frr_pthread_hash_mtx);{holder.attr.id=id;fpt
=hash_lookup(frr_pthread_hash,&holder);}pthread_mutex_unlock(&frr_pthread_hash_m
tx);returnfpt;}intfrr_pthread_run(structfrr_pthread*fpt,constpthread_attr_t*attr
){intret;ret=pthread_create(&fpt->thread,attr,fpt->attr.start,fpt);/**Perpthread
_create(3),thecontentsoffpt->threadareundefinedif*pthread_create()didnotsucceed.
Resetthisvaluetozero.*/if(ret<0)memset(&fpt->thread,0x00,sizeof(fpt->thread));re
turnret;}voidfrr_pthread_wait_running(structfrr_pthread*fpt){pthread_mutex_lock(
fpt->running_cond_mtx);{while(!fpt->running)pthread_cond_wait(fpt->running_cond,
fpt->running_cond_mtx);}pthread_mutex_unlock(fpt->running_cond_mtx);}voidfrr_pth
read_notify_running(structfrr_pthread*fpt){pthread_mutex_lock(fpt->running_cond_
mtx);{fpt->running=true;pthread_cond_signal(fpt->running_cond);}pthread_mutex_un
lock(fpt->running_cond_mtx);}intfrr_pthread_stop(structfrr_pthread*fpt,void**res
ult){intret=(*fpt->attr.stop)(fpt,result);memset(&fpt->thread,0x00,sizeof(fpt->t
hread));returnret;}/**Callbackforhash_iteratetostopallfrr_pthread's.*/staticvoid
frr_pthread_stop_all_iter(structhash_backet*hb,void*arg){structfrr_pthread*fpt=h
b->data;frr_pthread_stop(fpt,NULL);}voidfrr_pthread_stop_all(){pthread_mutex_loc
k(&frr_pthread_hash_mtx);{hash_iterate(frr_pthread_hash,frr_pthread_stop_all_ite
r,NULL);}pthread_mutex_unlock(&frr_pthread_hash_mtx);}uint32_tfrr_pthread_get_id
(void){_Atomicuint32_tnxid;nxid=atomic_fetch_add_explicit(&next_id,1,memory_orde
r_seq_cst);/*justasanitycheck,thisshouldneverhappen*/assert(nxid<=(UINT32_MAX-1)
);returnnxid;}voidfrr_pthread_yield(void){(void)sched_yield();}/**--------------
--------------------------------------------------------------*DefaultEventLoop*
----------------------------------------------------------------------------*//*
dummytaskforsleeperpipe*/staticintfpt_dummy(structthread*thread){return0;}/*pois
onpilltasktoendeventloop*/staticintfpt_finish(structthread*thread){structfrr_pth
read*fpt=THREAD_ARG(thread);atomic_store_explicit(&fpt->running,false,memory_ord
er_relaxed);return0;}/*stopfunction,calledfromotherthreadstohaltthisone*/statici
ntfpt_halt(structfrr_pthread*fpt,void**res){thread_add_event(fpt->master,&fpt_fi
nish,fpt,0,NULL);pthread_join(fpt->thread,res);fpt=NULL;return0;}/*entrypthreadf
unction&maineventloop*/staticvoid*fpt_run(void*arg){structfrr_pthread*fpt=arg;fp
t->master->owner=pthread_self();intsleeper[2];pipe(sleeper);thread_add_read(fpt-
>master,&fpt_dummy,NULL,sleeper[0],NULL);fpt->master->handle_signals=false;frr_p
thread_notify_running(fpt);structthreadtask;while(atomic_load_explicit(&fpt->run
ning,memory_order_relaxed)){if(thread_fetch(fpt->master,&task)){thread_call(&tas
k);}}close(sleeper[1]);close(sleeper[0]);returnNULL;}