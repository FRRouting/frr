/*-*Copyright(c)1991,1993*TheRegentsoftheUniversityofCalifornia.Allrightsreserve
d.**Redistributionanduseinsourceandbinaryforms,withorwithout*modification,areper
mittedprovidedthatthefollowingconditions*aremet:*1.Redistributionsofsourcecodemu
stretaintheabovecopyright*notice,thislistofconditionsandthefollowingdisclaimer.*
2.Redistributionsinbinaryformmustreproducetheabovecopyright*notice,thislistofcon
ditionsandthefollowingdisclaimerinthe*documentationand/orothermaterialsprovidedw
iththedistribution.*4.NeitherthenameoftheUniversitynorthenamesofitscontributors*
maybeusedtoendorseorpromoteproductsderivedfromthissoftware*withoutspecificpriorw
rittenpermission.**THISSOFTWAREISPROVIDEDBYTHEREGENTSANDCONTRIBUTORS``ASIS''AND*
ANYEXPRESSORIMPLIEDWARRANTIES,INCLUDING,BUTNOTLIMITEDTO,THE*IMPLIEDWARRANTIESOFM
ERCHANTABILITYANDFITNESSFORAPARTICULARPURPOSE*AREDISCLAIMED.INNOEVENTSHALLTHEREG
ENTSORCONTRIBUTORSBELIABLE*FORANYDIRECT,INDIRECT,INCIDENTAL,SPECIAL,EXEMPLARY,OR
CONSEQUENTIAL*DAMAGES(INCLUDING,BUTNOTLIMITEDTO,PROCUREMENTOFSUBSTITUTEGOODS*ORS
ERVICES;LOSSOFUSE,DATA,ORPROFITS;ORBUSINESSINTERRUPTION)*HOWEVERCAUSEDANDONANYTH
EORYOFLIABILITY,WHETHERINCONTRACT,STRICT*LIABILITY,ORTORT(INCLUDINGNEGLIGENCEORO
THERWISE)ARISINGINANYWAY*OUTOFTHEUSEOFTHISSOFTWARE,EVENIFADVISEDOFTHEPOSSIBILITY
OF*SUCHDAMAGE.**@(#)queue.h8.5(Berkeley)8/20/94*$FreeBSD$*/#ifndef_SYS_QUEUE_H_#
define_SYS_QUEUE_H_/**Thisfiledefinesfourtypesofdatastructures:singly-linkedlist
s,*singly-linkedtailqueues,listsandtailqueues.**Asingly-linkedlistisheadedbyasin
gleforwardpointer.Theelements*aresinglylinkedforminimumspaceandpointermanipulati
onoverheadat*theexpenseofO(n)removalforarbitraryelements.Newelementscanbe*addedt
othelistafteranexistingelementorattheheadofthelist.*Elementsbeingremovedfromtheh
eadofthelistshouldusetheexplicit*macroforthispurposeforoptimumefficiency.Asingly
-linkedlistmay*onlybetraversedintheforwarddirection.Singly-linkedlistsareideal*f
orapplicationswithlargedatasetsandfewornoremovalsorfor*implementingaLIFOqueue.**
Asingly-linkedtailqueueisheadedbyapairofpointers,onetothe*headofthelistandtheoth
ertothetailofthelist.Theelementsare*singlylinkedforminimumspaceandpointermanipul
ationoverheadatthe*expenseofO(n)removalforarbitraryelements.Newelementscanbeadde
d*tothelistafteranexistingelement,attheheadofthelist,oratthe*endofthelist.Elemen
tsbeingremovedfromtheheadofthetailqueue*shouldusetheexplicitmacroforthispurposef
oroptimumefficiency.*Asingly-linkedtailqueuemayonlybetraversedintheforwarddirect
ion.*Singly-linkedtailqueuesareidealforapplicationswithlargedatasets*andfewornor
emovalsorforimplementingaFIFOqueue.**Alistisheadedbyasingleforwardpointer(oranar
rayofforward*pointersforahashtableheader).Theelementsaredoublylinked*sothatanarb
itraryelementcanberemovedwithoutaneedto*traversethelist.Newelementscanbeaddedtot
helistbefore*orafteranexistingelementorattheheadofthelist.Alist*mayonlybetravers
edintheforwarddirection.**Atailqueueisheadedbyapairofpointers,onetotheheadofthe*
listandtheothertothetailofthelist.Theelementsaredoubly*linkedsothatanarbitraryel
ementcanberemovedwithoutaneedto*traversethelist.Newelementscanbeaddedtothelistbe
foreor*afteranexistingelement,attheheadofthelist,orattheendof*thelist.Atailqueue
maybetraversedineitherdirection.**Fordetailsontheuseofthesemacros,seethequeue(3)
manualpage.***SLISTLISTSTAILQTAILQ*_HEAD++++*_HEAD_INITIALIZER++++*_ENTRY++++*_I
NIT++++*_EMPTY++++*_FIRST++++*_NEXT++++*_PREV---+*_LAST--++*_FOREACH++++*_FOREAC
H_SAFE++++*_FOREACH_REVERSE---+*_FOREACH_REVERSE_SAFE---+*_INSERT_HEAD++++*_INSE
RT_BEFORE-+-+*_INSERT_AFTER++++*_INSERT_TAIL--++*_CONCAT--++*_REMOVE_AFTER+-+-*_
REMOVE_HEAD+-+-*_REMOVE++++*_SWAP++++**/#ifdefQUEUE_MACRO_DEBUG/*Storethelast2pl
acesthequeueelementorheadwasaltered*/structqm_trace{char*lastfile;intlastline;ch
ar*prevfile;intprevline;};#defineTRACEBUFstructqm_tracetrace;#defineTRASHIT(x)do
{(x)=(void*)-1;}while(0)#defineQMD_SAVELINK(name,link)void**name=(void*)&(link)#
defineQMD_TRACE_HEAD(head)\do{\(head)->trace.prevline=(head)->trace.lastline;\(h
ead)->trace.prevfile=(head)->trace.lastfile;\(head)->trace.lastline=__LINE__;\(h
ead)->trace.lastfile=__FILE__;\}while(0)#defineQMD_TRACE_ELEM(elem)\do{\(elem)->
trace.prevline=(elem)->trace.lastline;\(elem)->trace.prevfile=(elem)->trace.last
file;\(elem)->trace.lastline=__LINE__;\(elem)->trace.lastfile=__FILE__;\}while(0
)#else#defineQMD_TRACE_ELEM(elem)#defineQMD_TRACE_HEAD(head)#defineQMD_SAVELINK(
name,link)#defineTRACEBUF#defineTRASHIT(x)#endif/*QUEUE_MACRO_DEBUG*//**Singly-l
inkedListdeclarations.*/#defineSLIST_HEAD(name,type)\structname{\structtype*slh_
first;/*firstelement*/\}#defineSLIST_HEAD_INITIALIZER(head)\{\NULL\}#defineSLIST
_ENTRY(type)\struct{\structtype*sle_next;/*nextelement*/\}/**Singly-linkedListfu
nctions.*/#defineSLIST_EMPTY(head)((head)->slh_first==NULL)#defineSLIST_FIRST(he
ad)((head)->slh_first)#defineSLIST_FOREACH(var,head,field)\for((var)=SLIST_FIRST
((head));(var);\(var)=SLIST_NEXT((var),field))#defineSLIST_FOREACH_SAFE(var,head
,field,tvar)\for((var)=SLIST_FIRST((head));\(var)&&((tvar)=SLIST_NEXT((var),fiel
d),1);(var)=(tvar))#defineSLIST_FOREACH_PREVPTR(var,varp,head,field)\for((varp)=
&SLIST_FIRST((head));((var)=*(varp))!=NULL;\(varp)=&SLIST_NEXT((var),field))#def
ineSLIST_INIT(head)\do{\SLIST_FIRST((head))=NULL;\}while(0)#defineSLIST_INSERT_A
FTER(slistelm,elm,field)\do{\SLIST_NEXT((elm),field)=SLIST_NEXT((slistelm),field
);\SLIST_NEXT((slistelm),field)=(elm);\}while(0)#defineSLIST_INSERT_HEAD(head,el
m,field)\do{\SLIST_NEXT((elm),field)=SLIST_FIRST((head));\SLIST_FIRST((head))=(e
lm);\}while(0)#defineSLIST_NEXT(elm,field)((elm)->field.sle_next)#defineSLIST_RE
MOVE(head,elm,type,field)\do{\QMD_SAVELINK(oldnext,(elm)->field.sle_next);\if(SL
IST_FIRST((head))==(elm)){\SLIST_REMOVE_HEAD((head),field);\}else{\structtype*cu
relm=SLIST_FIRST((head));\while(SLIST_NEXT(curelm,field)!=(elm))\curelm=SLIST_NE
XT(curelm,field);\SLIST_REMOVE_AFTER(curelm,field);\}\TRASHIT(*oldnext);\}while(
0)#defineSLIST_REMOVE_AFTER(elm,field)\do{\SLIST_NEXT(elm,field)=\SLIST_NEXT(SLI
ST_NEXT(elm,field),field);\}while(0)#defineSLIST_REMOVE_HEAD(head,field)\do{\SLI
ST_FIRST((head))=SLIST_NEXT(SLIST_FIRST((head)),field);\}while(0)#defineSLIST_SW
AP(head1,head2,type)\do{\structtype*swap_first=SLIST_FIRST(head1);\SLIST_FIRST(h
ead1)=SLIST_FIRST(head2);\SLIST_FIRST(head2)=swap_first;\}while(0)/**Singly-link
edTailqueuedeclarations.*/#defineSTAILQ_HEAD(name,type)\structname{\structtype*s
tqh_first;/*firstelement*/\structtype**stqh_last;/*addroflastnextelement*/\}#def
ineSTAILQ_HEAD_INITIALIZER(head)\{\NULL,&(head).stqh_first\}#defineSTAILQ_ENTRY(
type)\struct{\structtype*stqe_next;/*nextelement*/\}/**Singly-linkedTailqueuefun
ctions.*/#defineSTAILQ_CONCAT(head1,head2)\do{\if(!STAILQ_EMPTY((head2))){\*(hea
d1)->stqh_last=(head2)->stqh_first;\(head1)->stqh_last=(head2)->stqh_last;\STAIL
Q_INIT((head2));\}\}while(0)#defineSTAILQ_EMPTY(head)((head)->stqh_first==NULL)#
defineSTAILQ_FIRST(head)((head)->stqh_first)#defineSTAILQ_FOREACH(var,head,field
)\for((var)=STAILQ_FIRST((head));(var);\(var)=STAILQ_NEXT((var),field))#defineST
AILQ_FOREACH_SAFE(var,head,field,tvar)\for((var)=STAILQ_FIRST((head));\(var)&&((
tvar)=STAILQ_NEXT((var),field),1);(var)=(tvar))#defineSTAILQ_INIT(head)\do{\STAI
LQ_FIRST((head))=NULL;\(head)->stqh_last=&STAILQ_FIRST((head));\}while(0)#define
STAILQ_INSERT_AFTER(head,tqelm,elm,field)\do{\if((STAILQ_NEXT((elm),field)=STAIL
Q_NEXT((tqelm),field))\==NULL)\(head)->stqh_last=&STAILQ_NEXT((elm),field);\STAI
LQ_NEXT((tqelm),field)=(elm);\}while(0)#defineSTAILQ_INSERT_HEAD(head,elm,field)
\do{\if((STAILQ_NEXT((elm),field)=STAILQ_FIRST((head)))\==NULL)\(head)->stqh_las
t=&STAILQ_NEXT((elm),field);\STAILQ_FIRST((head))=(elm);\}while(0)#defineSTAILQ_
INSERT_TAIL(head,elm,field)\do{\STAILQ_NEXT((elm),field)=NULL;\*(head)->stqh_las
t=(elm);\(head)->stqh_last=&STAILQ_NEXT((elm),field);\}while(0)#defineSTAILQ_LAS
T(head,type,field)\(STAILQ_EMPTY((head))\?NULL\:((structtype*)(void*)((char*)((h
ead)->stqh_last)\-offsetof(structtype,field))))#defineSTAILQ_NEXT(elm,field)((el
m)->field.stqe_next)#defineSTAILQ_REMOVE(head,elm,type,field)\do{\QMD_SAVELINK(o
ldnext,(elm)->field.stqe_next);\if(STAILQ_FIRST((head))==(elm)){\STAILQ_REMOVE_H
EAD((head),field);\}else{\structtype*curelm=STAILQ_FIRST((head));\while(STAILQ_N
EXT(curelm,field)!=(elm))\curelm=STAILQ_NEXT(curelm,field);\STAILQ_REMOVE_AFTER(
head,curelm,field);\}\TRASHIT(*oldnext);\}while(0)#defineSTAILQ_REMOVE_AFTER(hea
d,elm,field)\do{\if((STAILQ_NEXT(elm,field)=\STAILQ_NEXT(STAILQ_NEXT(elm,field),
field))\==NULL)\(head)->stqh_last=&STAILQ_NEXT((elm),field);\}while(0)#defineSTA
ILQ_REMOVE_HEAD(head,field)\do{\if((STAILQ_FIRST((head))=\STAILQ_NEXT(STAILQ_FIR
ST((head)),field))\==NULL)\(head)->stqh_last=&STAILQ_FIRST((head));\}while(0)#de
fineSTAILQ_SWAP(head1,head2,type)\do{\structtype*swap_first=STAILQ_FIRST(head1);
\structtype**swap_last=(head1)->stqh_last;\STAILQ_FIRST(head1)=STAILQ_FIRST(head
2);\(head1)->stqh_last=(head2)->stqh_last;\STAILQ_FIRST(head2)=swap_first;\(head
2)->stqh_last=swap_last;\if(STAILQ_EMPTY(head1))\(head1)->stqh_last=&STAILQ_FIRS
T(head1);\if(STAILQ_EMPTY(head2))\(head2)->stqh_last=&STAILQ_FIRST(head2);\}whil
e(0)/**Listdeclarations.*/#defineLIST_HEAD(name,type)\structname{\structtype*lh_
first;/*firstelement*/\}#defineLIST_HEAD_INITIALIZER(head)\{\NULL\}#defineLIST_E
NTRY(type)\struct{\structtype*le_next;/*nextelement*/\structtype**le_prev;/*addr
essofpreviousnextelement*/\}/**Listfunctions.*/#if(defined(_KERNEL)&&defined(INV
ARIANTS))#defineQMD_LIST_CHECK_HEAD(head,field)\do{\if(LIST_FIRST((head))!=NULL\
&&LIST_FIRST((head))->field.le_prev\!=&LIST_FIRST((head)))\panic("Badlisthead%pf
irst->prev!=head",(head));\}while(0)#defineQMD_LIST_CHECK_NEXT(elm,field)\do{\if
(LIST_NEXT((elm),field)!=NULL\&&LIST_NEXT((elm),field)->field.le_prev\!=&((elm)-
>field.le_next))\panic("Badlinkelm%pnext->prev!=elm",(elm));\}while(0)#defineQMD
_LIST_CHECK_PREV(elm,field)\do{\if(*(elm)->field.le_prev!=(elm))\panic("Badlinke
lm%pprev->next!=elm",(elm));\}while(0)#else#defineQMD_LIST_CHECK_HEAD(head,field
)#defineQMD_LIST_CHECK_NEXT(elm,field)#defineQMD_LIST_CHECK_PREV(elm,field)#endi
f/*(_KERNEL&&INVARIANTS)*/#defineLIST_EMPTY(head)((head)->lh_first==NULL)#define
LIST_FIRST(head)((head)->lh_first)#defineLIST_FOREACH(var,head,field)\for((var)=
LIST_FIRST((head));(var);(var)=LIST_NEXT((var),field))#defineLIST_FOREACH_SAFE(v
ar,head,field,tvar)\for((var)=LIST_FIRST((head));\(var)&&((tvar)=LIST_NEXT((var)
,field),1);(var)=(tvar))#defineLIST_INIT(head)\do{\LIST_FIRST((head))=NULL;\}whi
le(0)#defineLIST_INSERT_AFTER(listelm,elm,field)\do{\QMD_LIST_CHECK_NEXT(listelm
,field);\if((LIST_NEXT((elm),field)=LIST_NEXT((listelm),field))\!=NULL)\LIST_NEX
T((listelm),field)->field.le_prev=\&LIST_NEXT((elm),field);\LIST_NEXT((listelm),
field)=(elm);\(elm)->field.le_prev=&LIST_NEXT((listelm),field);\}while(0)#define
LIST_INSERT_BEFORE(listelm,elm,field)\do{\QMD_LIST_CHECK_PREV(listelm,field);\(e
lm)->field.le_prev=(listelm)->field.le_prev;\LIST_NEXT((elm),field)=(listelm);\*
(listelm)->field.le_prev=(elm);\(listelm)->field.le_prev=&LIST_NEXT((elm),field)
;\}while(0)#defineLIST_INSERT_HEAD(head,elm,field)\do{\QMD_LIST_CHECK_HEAD((head
),field);\if((LIST_NEXT((elm),field)=LIST_FIRST((head)))!=NULL)\LIST_FIRST((head
))->field.le_prev=\&LIST_NEXT((elm),field);\LIST_FIRST((head))=(elm);\(elm)->fie
ld.le_prev=&LIST_FIRST((head));\}while(0)#defineLIST_NEXT(elm,field)((elm)->fiel
d.le_next)#defineLIST_REMOVE(elm,field)\do{\QMD_SAVELINK(oldnext,(elm)->field.le
_next);\QMD_SAVELINK(oldprev,(elm)->field.le_prev);\QMD_LIST_CHECK_NEXT(elm,fiel
d);\QMD_LIST_CHECK_PREV(elm,field);\if(LIST_NEXT((elm),field)!=NULL)\LIST_NEXT((
elm),field)->field.le_prev=\(elm)->field.le_prev;\*(elm)->field.le_prev=LIST_NEX
T((elm),field);\TRASHIT(*oldnext);\TRASHIT(*oldprev);\}while(0)#defineLIST_SWAP(
head1,head2,type,field)\do{\structtype*swap_tmp=LIST_FIRST((head1));\LIST_FIRST(
(head1))=LIST_FIRST((head2));\LIST_FIRST((head2))=swap_tmp;\if((swap_tmp=LIST_FI
RST((head1)))!=NULL)\swap_tmp->field.le_prev=&LIST_FIRST((head1));\if((swap_tmp=
LIST_FIRST((head2)))!=NULL)\swap_tmp->field.le_prev=&LIST_FIRST((head2));\}while
(0)/**Tailqueuedeclarations.*/#defineTAILQ_HEAD(name,type)\structname{\structtyp
e*tqh_first;/*firstelement*/\structtype**tqh_last;/*addroflastnextelement*/\TRAC
EBUF\}#defineTAILQ_HEAD_INITIALIZER(head)\{\NULL,&(head).tqh_first\}#defineTAILQ
_ENTRY(type)\struct{\structtype*tqe_next;/*nextelement*/\structtype**tqe_prev;/*
addressofpreviousnextelement*/\TRACEBUF\}/**Tailqueuefunctions.*/#if(defined(_KE
RNEL)&&defined(INVARIANTS))#defineQMD_TAILQ_CHECK_HEAD(head,field)\do{\if(!TAILQ
_EMPTY(head)\&&TAILQ_FIRST((head))->field.tqe_prev\!=&TAILQ_FIRST((head)))\panic
("Badtailqhead%pfirst->prev!=head",\(head));\}while(0)#defineQMD_TAILQ_CHECK_TAI
L(head,field)\do{\if(*(head)->tqh_last!=NULL)\panic("BadtailqNEXT(%p->tqh_last)!
=NULL",(head));\}while(0)#defineQMD_TAILQ_CHECK_NEXT(elm,field)\do{\if(TAILQ_NEX
T((elm),field)!=NULL\&&TAILQ_NEXT((elm),field)->field.tqe_prev\!=&((elm)->field.
tqe_next))\panic("Badlinkelm%pnext->prev!=elm",(elm));\}while(0)#defineQMD_TAILQ
_CHECK_PREV(elm,field)\do{\if(*(elm)->field.tqe_prev!=(elm))\panic("Badlinkelm%p
prev->next!=elm",(elm));\}while(0)#else#defineQMD_TAILQ_CHECK_HEAD(head,field)#d
efineQMD_TAILQ_CHECK_TAIL(head,headname)#defineQMD_TAILQ_CHECK_NEXT(elm,field)#d
efineQMD_TAILQ_CHECK_PREV(elm,field)#endif/*(_KERNEL&&INVARIANTS)*/#defineTAILQ_
CONCAT(head1,head2,field)\do{\if(!TAILQ_EMPTY(head2)){\*(head1)->tqh_last=(head2
)->tqh_first;\(head2)->tqh_first->field.tqe_prev=\(head1)->tqh_last;\(head1)->tq
h_last=(head2)->tqh_last;\TAILQ_INIT((head2));\QMD_TRACE_HEAD(head1);\QMD_TRACE_
HEAD(head2);\}\}while(0)#defineTAILQ_EMPTY(head)((head)->tqh_first==NULL)#define
TAILQ_FIRST(head)((head)->tqh_first)#defineTAILQ_FOREACH(var,head,field)\for((va
r)=TAILQ_FIRST((head));(var);\(var)=TAILQ_NEXT((var),field))#defineTAILQ_FOREACH
_SAFE(var,head,field,tvar)\for((var)=TAILQ_FIRST((head));\(var)&&((tvar)=TAILQ_N
EXT((var),field),1);(var)=(tvar))#defineTAILQ_FOREACH_REVERSE(var,head,headname,
field)\for((var)=TAILQ_LAST((head),headname);(var);\(var)=TAILQ_PREV((var),headn
ame,field))#defineTAILQ_FOREACH_REVERSE_SAFE(var,head,headname,field,tvar)\for((
var)=TAILQ_LAST((head),headname);\(var)&&((tvar)=TAILQ_PREV((var),headname,field
),1);\(var)=(tvar))#defineTAILQ_INIT(head)\do{\TAILQ_FIRST((head))=NULL;\(head)-
>tqh_last=&TAILQ_FIRST((head));\QMD_TRACE_HEAD(head);\}while(0)#defineTAILQ_INSE
RT_AFTER(head,listelm,elm,field)\do{\QMD_TAILQ_CHECK_NEXT(listelm,field);\if((TA
ILQ_NEXT((elm),field)=TAILQ_NEXT((listelm),field))\!=NULL)\TAILQ_NEXT((elm),fiel
d)->field.tqe_prev=\&TAILQ_NEXT((elm),field);\else{\(head)->tqh_last=&TAILQ_NEXT
((elm),field);\QMD_TRACE_HEAD(head);\}\TAILQ_NEXT((listelm),field)=(elm);\(elm)-
>field.tqe_prev=&TAILQ_NEXT((listelm),field);\QMD_TRACE_ELEM(&(elm)->field);\QMD
_TRACE_ELEM(&listelm->field);\}while(0)#defineTAILQ_INSERT_BEFORE(listelm,elm,fi
eld)\do{\QMD_TAILQ_CHECK_PREV(listelm,field);\(elm)->field.tqe_prev=(listelm)->f
ield.tqe_prev;\TAILQ_NEXT((elm),field)=(listelm);\*(listelm)->field.tqe_prev=(el
m);\(listelm)->field.tqe_prev=&TAILQ_NEXT((elm),field);\QMD_TRACE_ELEM(&(elm)->f
ield);\QMD_TRACE_ELEM(&listelm->field);\}while(0)#defineTAILQ_INSERT_HEAD(head,e
lm,field)\do{\QMD_TAILQ_CHECK_HEAD(head,field);\if((TAILQ_NEXT((elm),field)=TAIL
Q_FIRST((head)))!=NULL)\TAILQ_FIRST((head))->field.tqe_prev=\&TAILQ_NEXT((elm),f
ield);\else\(head)->tqh_last=&TAILQ_NEXT((elm),field);\TAILQ_FIRST((head))=(elm)
;\(elm)->field.tqe_prev=&TAILQ_FIRST((head));\QMD_TRACE_HEAD(head);\QMD_TRACE_EL
EM(&(elm)->field);\}while(0)#defineTAILQ_INSERT_TAIL(head,elm,field)\do{\QMD_TAI
LQ_CHECK_TAIL(head,field);\TAILQ_NEXT((elm),field)=NULL;\(elm)->field.tqe_prev=(
head)->tqh_last;\*(head)->tqh_last=(elm);\(head)->tqh_last=&TAILQ_NEXT((elm),fie
ld);\QMD_TRACE_HEAD(head);\QMD_TRACE_ELEM(&(elm)->field);\}while(0)#defineTAILQ_
LAST(head,headname)\(*(((structheadname*)((head)->tqh_last))->tqh_last))#defineT
AILQ_NEXT(elm,field)((elm)->field.tqe_next)#defineTAILQ_PREV(elm,headname,field)
\(*(((structheadname*)((elm)->field.tqe_prev))->tqh_last))#defineTAILQ_REMOVE(he
ad,elm,field)\do{\QMD_SAVELINK(oldnext,(elm)->field.tqe_next);\QMD_SAVELINK(oldp
rev,(elm)->field.tqe_prev);\QMD_TAILQ_CHECK_NEXT(elm,field);\QMD_TAILQ_CHECK_PRE
V(elm,field);\if((TAILQ_NEXT((elm),field))!=NULL)\TAILQ_NEXT((elm),field)->field
.tqe_prev=\(elm)->field.tqe_prev;\else{\(head)->tqh_last=(elm)->field.tqe_prev;\
QMD_TRACE_HEAD(head);\}\*(elm)->field.tqe_prev=TAILQ_NEXT((elm),field);\TRASHIT(
*oldnext);\TRASHIT(*oldprev);\QMD_TRACE_ELEM(&(elm)->field);\}while(0)#defineTAI
LQ_SWAP(head1,head2,type,field)\do{\structtype*swap_first=(head1)->tqh_first;\st
ructtype**swap_last=(head1)->tqh_last;\(head1)->tqh_first=(head2)->tqh_first;\(h
ead1)->tqh_last=(head2)->tqh_last;\(head2)->tqh_first=swap_first;\(head2)->tqh_l
ast=swap_last;\if((swap_first=(head1)->tqh_first)!=NULL)\swap_first->field.tqe_p
rev=&(head1)->tqh_first;\else\(head1)->tqh_last=&(head1)->tqh_first;\if((swap_fi
rst=(head2)->tqh_first)!=NULL)\swap_first->field.tqe_prev=&(head2)->tqh_first;\e
lse\(head2)->tqh_last=&(head2)->tqh_first;\}while(0)#endif/*!_SYS_QUEUE_H_*/