/*Hashroutine.*Copyright(C)1998KunihiroIshiguro**ThisfileispartofGNUZebra.**GNUZ
ebraisfreesoftware;youcanredistributeitand/ormodify*itunderthetermsoftheGNUGener
alPublicLicenseaspublished*bytheFreeSoftwareFoundation;eitherversion2,or(atyour*
option)anylaterversion.**GNUZebraisdistributedinthehopethatitwillbeuseful,but*WI
THOUTANYWARRANTY;withouteventheimpliedwarrantyof*MERCHANTABILITYorFITNESSFORAPAR
TICULARPURPOSE.SeetheGNU*GeneralPublicLicenseformoredetails.**Youshouldhaverecei
vedacopyoftheGNUGeneralPublicLicensealong*withthisprogram;seethefileCOPYING;ifno
t,writetotheFreeSoftware*Foundation,Inc.,51FranklinSt,FifthFloor,Boston,MA02110-
1301USA*/#include<zebra.h>#include<math.h>#include"hash.h"#include"memory.h"#inc
lude"linklist.h"#include"termtable.h"#include"vty.h"#include"command.h"#include"
libfrr.h"DEFINE_MTYPE(LIB,HASH,"Hash")DEFINE_MTYPE(LIB,HASH_BACKET,"HashBucket")
DEFINE_MTYPE_STATIC(LIB,HASH_INDEX,"HashIndex")pthread_mutex_t_hashes_mtx=PTHREA
D_MUTEX_INITIALIZER;staticstructlist*_hashes;/*Allocateanewhash.*/structhash*has
h_create_size(unsignedintsize,unsignedint(*hash_key)(void*),int(*hash_cmp)(const
void*,constvoid*),constchar*name){structhash*hash;assert((size&(size-1))==0);has
h=XCALLOC(MTYPE_HASH,sizeof(structhash));hash->index=XCALLOC(MTYPE_HASH_INDEX,si
zeof(structhash_backet*)*size);hash->size=size;hash->hash_key=hash_key;hash->has
h_cmp=hash_cmp;hash->count=0;hash->name=name?XSTRDUP(MTYPE_HASH,name):NULL;hash-
>stats.empty=hash->size;pthread_mutex_lock(&_hashes_mtx);{if(!_hashes)_hashes=li
st_new();listnode_add(_hashes,hash);}pthread_mutex_unlock(&_hashes_mtx);returnha
sh;}/*Allocateanewhashwithdefaulthashsize.*/structhash*hash_create(unsignedint(*
hash_key)(void*),int(*hash_cmp)(constvoid*,constvoid*),constchar*name){returnhas
h_create_size(HASH_INITIAL_SIZE,hash_key,hash_cmp,name);}/*Utilityfunctionforhas
h_get().Whenthisfunctionisspecifiedasalloc_func,returnarugmentasitis.Thisfunctio
nisusedforinternalreadyallocatedvalue.*/void*hash_alloc_intern(void*arg){returna
rg;}#definehash_update_ssq(hz,old,new)\atomic_fetch_add_explicit(&hz->stats.ssq,
(new+old)*(new-old),\memory_order_relaxed);/*Expandhashifthechainlengthexceedsth
ethreshold.*/staticvoidhash_expand(structhash*hash){unsignedinti,new_size;struct
hash_backet*hb,*hbnext,**new_index;new_size=hash->size*2;if(hash->max_size&&new_
size>hash->max_size)return;new_index=XCALLOC(MTYPE_HASH_INDEX,sizeof(structhash_
backet*)*new_size);if(new_index==NULL)return;hash->stats.empty=new_size;for(i=0;
i<hash->size;i++)for(hb=hash->index[i];hb;hb=hbnext){unsignedinth=hb->key&(new_s
ize-1);hbnext=hb->next;hb->next=new_index[h];intoldlen=hb->next?hb->next->len:0;
intnewlen=oldlen+1;if(newlen==1)hash->stats.empty--;elsehb->next->len=0;hb->len=
newlen;hash_update_ssq(hash,oldlen,newlen);new_index[h]=hb;}/*Switchtonewtable*/
XFREE(MTYPE_HASH_INDEX,hash->index);hash->size=new_size;hash->index=new_index;}/
*Lookupandreturnhashbacketinhash.Ifthereisnocorrespondinghashbacketandalloc_func
isspecified,createnewhashbacket.*/void*hash_get(structhash*hash,void*data,void*(
*alloc_func)(void*)){unsignedintkey;unsignedintindex;void*newdata;structhash_bac
ket*backet;if(!alloc_func&&!hash->count)returnNULL;key=(*hash->hash_key)(data);i
ndex=key&(hash->size-1);for(backet=hash->index[index];backet!=NULL;backet=backet
->next){if(backet->key==key&&(*hash->hash_cmp)(backet->data,data))returnbacket->
data;}if(alloc_func){newdata=(*alloc_func)(data);if(newdata==NULL)returnNULL;if(
HASH_THRESHOLD(hash->count+1,hash->size)){hash_expand(hash);index=key&(hash->siz
e-1);}backet=XCALLOC(MTYPE_HASH_BACKET,sizeof(structhash_backet));backet->data=n
ewdata;backet->key=key;backet->next=hash->index[index];hash->index[index]=backet
;hash->count++;intoldlen=backet->next?backet->next->len:0;intnewlen=oldlen+1;if(
newlen==1)hash->stats.empty--;elsebacket->next->len=0;backet->len=newlen;hash_up
date_ssq(hash,oldlen,newlen);returnbacket->data;}returnNULL;}/*Hashlookup.*/void
*hash_lookup(structhash*hash,void*data){returnhash_get(hash,data,NULL);}/*Simple
Bernsteinhashwhichissimpleandfastforcommoncase*/unsignedintstring_hash_make(cons
tchar*str){unsignedinthash=0;while(*str)hash=(hash*33)^(unsignedint)*str++;retur
nhash;}/*Thisfunctionreleaseregisteredvaluefromspecifiedhash.Whenreleaseissucces
sfullyfinished,returnthedatapointerinthehashbacket.*/void*hash_release(structhas
h*hash,void*data){void*ret;unsignedintkey;unsignedintindex;structhash_backet*bac
ket;structhash_backet*pp;key=(*hash->hash_key)(data);index=key&(hash->size-1);fo
r(backet=pp=hash->index[index];backet;backet=backet->next){if(backet->key==key&&
(*hash->hash_cmp)(backet->data,data)){intoldlen=hash->index[index]->len;intnewle
n=oldlen-1;if(backet==pp)hash->index[index]=backet->next;elsepp->next=backet->ne
xt;if(hash->index[index])hash->index[index]->len=newlen;elsehash->stats.empty++;
hash_update_ssq(hash,oldlen,newlen);ret=backet->data;XFREE(MTYPE_HASH_BACKET,bac
ket);hash->count--;returnret;}pp=backet;}returnNULL;}/*Iteratorfunctionforhash.*
/voidhash_iterate(structhash*hash,void(*func)(structhash_backet*,void*),void*arg
){unsignedinti;structhash_backet*hb;structhash_backet*hbnext;for(i=0;i<hash->siz
e;i++)for(hb=hash->index[i];hb;hb=hbnext){/*getpointertonexthashbackethere,incas
e(*func)*decidestodeletehbbycallinghash_release*/hbnext=hb->next;(*func)(hb,arg)
;}}/*Iteratorfunctionforhash.*/voidhash_walk(structhash*hash,int(*func)(structha
sh_backet*,void*),void*arg){unsignedinti;structhash_backet*hb;structhash_backet*
hbnext;intret=HASHWALK_CONTINUE;for(i=0;i<hash->size;i++){for(hb=hash->index[i];
hb;hb=hbnext){/*getpointertonexthashbackethere,incase(*func)*decidestodeletehbby
callinghash_release*/hbnext=hb->next;ret=(*func)(hb,arg);if(ret==HASHWALK_ABORT)
return;}}}/*Cleanuphash.*/voidhash_clean(structhash*hash,void(*free_func)(void*)
){unsignedinti;structhash_backet*hb;structhash_backet*next;for(i=0;i<hash->size;
i++){for(hb=hash->index[i];hb;hb=next){next=hb->next;if(free_func)(*free_func)(h
b->data);XFREE(MTYPE_HASH_BACKET,hb);hash->count--;}hash->index[i]=NULL;}hash->s
tats.ssq=0;hash->stats.empty=hash->size;}/*Freehashmemory.Youmaycallhash_cleanbe
forecallthisfunction.*/voidhash_free(structhash*hash){pthread_mutex_lock(&_hashe
s_mtx);{if(_hashes){listnode_delete(_hashes,hash);if(_hashes->count==0){list_del
ete_and_null(&_hashes);}}}pthread_mutex_unlock(&_hashes_mtx);if(hash->name)XFREE
(MTYPE_HASH,hash->name);XFREE(MTYPE_HASH_INDEX,hash->index);XFREE(MTYPE_HASH,has
h);}/*CLIcommands------------------------------------------------------------*/D
EFUN_NOSH(show_hash_stats,show_hash_stats_cmd,"showdebugginghashtable[statistics
]",SHOW_STRDEBUG_STR"Statisticsabouthashtables\n""Statisticsabouthashtables\n"){
structhash*h;structlistnode*ln;structttable*tt=ttable_new(&ttable_styles[TTSTYLE
_BLANK]);ttable_add_row(tt,"Hashtable|Buckets|Entries|Empty|LF|SD|FLF|SD");tt->s
tyle.cell.lpad=2;tt->style.cell.rpad=1;tt->style.corner='+';ttable_restyle(tt);t
table_rowseps(tt,0,BOTTOM,true,'-');/*Summarystatisticscalculatedare:**-Loadfact
or:Thisisthenumberofelementsinthetabledivided*bythenumberofbuckets.Sincethishash
tableimplementation*useschaining,thisvaluecanbegreaterthan1.*Thisnumberprovidesi
nformationonhow'full'thetableis,but*doesnotprovideinformationonhowevenlydistribu
tedthe*elementsare.*Notably,aloadfactor>=1doesnotimplythateverybuckethas*aneleme
nt;withapathologicalhashfunction,allelementscould*beinasinglebucket.**-Fullloadf
actor:thisisthenumberofelementsinthetable*dividedbythenumberofbucketsthathavesom
eelementsinthem.**-Std.Dev.:Thisisthestandarddeviationcalculatedfromthe*relevant
loadfactor.Iftheloadfactoristhemeanofnumberof*elementsperbucket,thestandarddevia
tionmeasureshowmuchany*particularbucketislikelytodeviatefromthemean.*Asaruleofth
umbthisnumbershouldbelessthan2,andideally*<=1foroptimalperformance.Anumberlarger
than3generally*indicatesapoorhashfunction.*/doublelf;//loadfactordoubleflf;//ful
lloadfactordoublevar;//overallvariancedoublefvar;//fullvariancedoublestdv;//over
allstddevdoublefstdv;//fullstddevlongdoublex2;//h->count^2longdoubleldc;//(longd
ouble)h->countlongdoublefull;//h->size-h->stats.emptylongdoublessq;//ssqcastedto
longdoublepthread_mutex_lock(&_hashes_mtx);if(!_hashes){pthread_mutex_unlock(&_h
ashes_mtx);ttable_del(tt);vty_out(vty,"Nohashtablesinuse.\n");returnCMD_SUCCESS;
}for(ALL_LIST_ELEMENTS_RO(_hashes,ln,h)){if(!h->name)continue;ssq=(longdouble)h-
>stats.ssq;x2=h->count*h->count;ldc=(longdouble)h->count;full=h->size-h->stats.e
mpty;lf=h->count/(double)h->size;flf=full?h->count/(double)(full):0;var=ldc?(1.0
/ldc)*(ssq-x2/ldc):0;fvar=full?(1.0/full)*(ssq-x2/full):0;var=(var<.0001)?0:var;
fvar=(fvar<.0001)?0:fvar;stdv=sqrt(var);fstdv=sqrt(fvar);ttable_add_row(tt,"%s|%
d|%ld|%.0f%%|%.2lf|%.2lf|%.2lf|%.2lf",h->name,h->size,h->count,(h->stats.empty/(
double)h->size)*100,lf,stdv,flf,fstdv);}pthread_mutex_unlock(&_hashes_mtx);/*dis
playheader*/charheader[]="Showinghashtablestatisticsfor";charunderln[sizeof(head
er)+strlen(frr_protonameinst)];memset(underln,'-',sizeof(underln));underln[sizeo
f(underln)-1]='\0';vty_out(vty,"%s%s\n",header,frr_protonameinst);vty_out(vty,"%
s\n",underln);vty_out(vty,"#allocated:%d\n",_hashes->count);vty_out(vty,"#named:
%d\n\n",tt->nrows-1);if(tt->nrows>1){ttable_colseps(tt,0,RIGHT,true,'|');char*ta
ble=ttable_dump(tt,"\n");vty_out(vty,"%s\n",table);XFREE(MTYPE_TMP,table);}elsev
ty_out(vty,"Nonamedhashtablestodisplay.\n");ttable_del(tt);returnCMD_SUCCESS;}vo
idhash_cmd_init(){install_element(ENABLE_NODE,&show_hash_stats_cmd);}