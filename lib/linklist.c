/*Genericlinkedlistroutine.*Copyright(C)1997,2000KunihiroIshiguro**Thisfileispar
tofGNUZebra.**GNUZebraisfreesoftware;youcanredistributeitand/ormodifyit*underthe
termsoftheGNUGeneralPublicLicenseaspublishedbythe*FreeSoftwareFoundation;eitherv
ersion2,or(atyouroption)any*laterversion.**GNUZebraisdistributedinthehopethatitw
illbeuseful,but*WITHOUTANYWARRANTY;withouteventheimpliedwarrantyof*MERCHANTABILI
TYorFITNESSFORAPARTICULARPURPOSE.SeetheGNU*GeneralPublicLicenseformoredetails.**
YoushouldhavereceivedacopyoftheGNUGeneralPublicLicensealong*withthisprogram;seet
hefileCOPYING;ifnot,writetotheFreeSoftware*Foundation,Inc.,51FranklinSt,FifthFlo
or,Boston,MA02110-1301USA*/#include<zebra.h>#include"linklist.h"#include"memory.
h"DEFINE_MTYPE_STATIC(LIB,LINK_LIST,"LinkList")DEFINE_MTYPE_STATIC(LIB,LINK_NODE
,"LinkNode")/*Allocatenewlist.*/structlist*list_new(void){returnXCALLOC(MTYPE_LI
NK_LIST,sizeof(structlist));}/*Freelist.*/staticvoidlist_free_internal(structlis
t*l){XFREE(MTYPE_LINK_LIST,l);}/*Allocatenewlistnode.Internaluseonly.*/staticstr
uctlistnode*listnode_new(void){returnXCALLOC(MTYPE_LINK_NODE,sizeof(structlistno
de));}/*Freelistnode.*/staticvoidlistnode_free(structlistnode*node){XFREE(MTYPE_
LINK_NODE,node);}/*Addnewdatatothelist.*/voidlistnode_add(structlist*list,void*v
al){structlistnode*node;assert(val!=NULL);node=listnode_new();node->prev=list->t
ail;node->data=val;if(list->head==NULL)list->head=node;elselist->tail->next=node
;list->tail=node;list->count++;}/**Addanodetothelist.Ifthelistwassortedaccording
tothe*cmpfunction,insertanewnodewiththegivenvalsuchthatthe*listremainssorted.The
newnodeisalwaysinserted;thereisno*notionofomittingduplicates.*/voidlistnode_add_
sort(structlist*list,void*val){structlistnode*n;structlistnode*new;assert(val!=N
ULL);new=listnode_new();new->data=val;if(list->cmp){for(n=list->head;n;n=n->next
){if((*list->cmp)(val,n->data)<0){new->next=n;new->prev=n->prev;if(n->prev)n->pr
ev->next=new;elselist->head=new;n->prev=new;list->count++;return;}}}new->prev=li
st->tail;if(list->tail)list->tail->next=new;elselist->head=new;list->tail=new;li
st->count++;}structlistnode*listnode_add_after(structlist*list,structlistnode*pp
,void*val){structlistnode*nn;assert(val!=NULL);nn=listnode_new();nn->data=val;if
(pp==NULL){if(list->head)list->head->prev=nn;elselist->tail=nn;nn->next=list->he
ad;nn->prev=pp;list->head=nn;}else{if(pp->next)pp->next->prev=nn;elselist->tail=
nn;nn->next=pp->next;nn->prev=pp;pp->next=nn;}list->count++;returnnn;}structlist
node*listnode_add_before(structlist*list,structlistnode*pp,void*val){structlistn
ode*nn;assert(val!=NULL);nn=listnode_new();nn->data=val;if(pp==NULL){if(list->ta
il)list->tail->next=nn;elselist->head=nn;nn->prev=list->tail;nn->next=pp;list->t
ail=nn;}else{if(pp->prev)pp->prev->next=nn;elselist->head=nn;nn->prev=pp->prev;n
n->next=pp;pp->prev=nn;}list->count++;returnnn;}/*Movegivenlistnodetotailoftheli
st*/voidlistnode_move_to_tail(structlist*l,structlistnode*n){LISTNODE_DETACH(l,n
);LISTNODE_ATTACH(l,n);}/*Deletespecificdatepointerfromthelist.*/voidlistnode_de
lete(structlist*list,void*val){structlistnode*node;assert(list);for(node=list->h
ead;node;node=node->next){if(node->data==val){if(node->prev)node->prev->next=nod
e->next;elselist->head=node->next;if(node->next)node->next->prev=node->prev;else
list->tail=node->prev;list->count--;listnode_free(node);return;}}}/*Returnfirstn
ode'sdataifitisthere.*/void*listnode_head(structlist*list){structlistnode*node;a
ssert(list);node=list->head;if(node)returnnode->data;returnNULL;}/*Deletealllist
nodefromthelist.*/voidlist_delete_all_node(structlist*list){structlistnode*node;
structlistnode*next;assert(list);for(node=list->head;node;node=next){next=node->
next;if(*list->del)(*list->del)(node->data);listnode_free(node);}list->head=list
->tail=NULL;list->count=0;}/*Deletealllistnodethenfreelistitself.*/voidlist_dele
te_and_null(structlist**list){assert(*list);list_delete_all_node(*list);list_fre
e_internal(*list);*list=NULL;}voidlist_delete_original(structlist*list){list_del
ete_and_null(&list);}/*Lookupthenodewhichhasgivendata.*/structlistnode*listnode_
lookup(structlist*list,void*data){structlistnode*node;assert(list);for(node=list
head(list);node;node=listnextnode(node))if(data==listgetdata(node))returnnode;re
turnNULL;}/*Deletethenodefromlist.Forospfdandospf6d.*/voidlist_delete_node(struc
tlist*list,structlistnode*node){if(node->prev)node->prev->next=node->next;elseli
st->head=node->next;if(node->next)node->next->prev=node->prev;elselist->tail=nod
e->prev;list->count--;listnode_free(node);}/*ospf_spf.c*/voidlist_add_list(struc
tlist*l,structlist*m){structlistnode*n;for(n=listhead(m);n;n=listnextnode(n))lis
tnode_add(l,n->data);}