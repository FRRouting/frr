/**Copyright1990WilliamPugh**Redistributionanduseinsourceandbinaryforms,withorwi
thout*modification,arepermitted.**THISSOFTWAREISPROVIDEDBYTHEAUTHORANDCONTRIBUTO
RS``ASIS''*ANDANYEXPRESSORIMPLIEDWARRANTIES,INCLUDING,BUTNOTLIMITED*TO,THEIMPLIE
DWARRANTIESOFMERCHANTABILITYANDFITNESSFORA*PARTICULARPURPOSEAREDISCLAIMED.INNOEV
ENTSHALLTHEAUTHOROR*CONTRIBUTORSBELIABLEFORANYDIRECT,INDIRECT,INCIDENTAL,*SPECIA
L,EXEMPLARY,ORCONSEQUENTIALDAMAGES(INCLUDING,BUTNOT*LIMITEDTO,PROCUREMENTOFSUBST
ITUTEGOODSORSERVICES;LOSSOF*USE,DATA,ORPROFITS;ORBUSINESSINTERRUPTION)HOWEVERCAU
SEDAND*ONANYTHEORYOFLIABILITY,WHETHERINCONTRACT,STRICTLIABILITY,*ORTORT(INCLUDIN
GNEGLIGENCEOROTHERWISE)ARISINGINANYWAYOUT*OFTHEUSEOFTHISSOFTWARE,EVENIFADVISEDOF
THEPOSSIBILITYOF*SUCHDAMAGE.**PermissiontoincludeinquaggaprovideonMarch31,2016*/
/**SkipListimpementationbasedoncodefromWilliamPugh.*ftp://ftp.cs.umd.edu/pub/ski
pLists/**SkipListsareaprobabilisticalternativetobalancedtrees,as*describedintheJ
une1990issueofCACMandwereinventedby*WilliamPughin1987.**Thisfilecontainssourceco
detoimplementadictionaryusing*skiplistsandatestdrivertotesttheroutines.**Acouple
ofcommentsaboutthisimplementation:*TheroutinerandomLevelhasbeenhard-codedtogener
aterandom*levelsusingp=0.25.Itcanbeeasilychanged.**Theinsertionroutinehasbeenimp
lementedsoastousethe*dirtyhackdescribedintheCACMpaper:ifarandomlevelis*generated
thatismorethanthecurrentmaximumlevel,the*currentmaximumlevelplusoneisusedinstead
.**LevelsstartatzeroandgouptoMaxLevel(whichisequalto*(MaxNumberOfLevels-1).**The
run-timeflagSKIPLIST_FLAG_ALLOW_DUPLICATESdetermineswhetheror*notduplicatesareal
lowedforagivenlist.Ifset,duplicatesare*allowedandactinaFIFOmanner.Ifnotset,anins
ertionofavalue*alreadyinthelistupdatesthepreviouslyexistingbinding.**BitsInRando
misdefinedtobethenumberofbitsreturnedbyacallto*random().Formostallmachineswith32
-bitintegers,thisis31bits*ascurrentlyset.*/#include<zebra.h>#include"memory.h"#i
nclude"log.h"#include"vty.h"#include"skiplist.h"DEFINE_MTYPE_STATIC(LIB,SKIP_LIS
T,"SkipList")DEFINE_MTYPE_STATIC(LIB,SKIP_LIST_NODE,"SkipNode")#defineBitsInRand
om31#defineMaxNumberOfLevels16#defineMaxLevel(MaxNumberOfLevels-1)#definenewNode
OfLevel(l)XCALLOC(MTYPE_SKIP_LIST_NODE,sizeof(structskiplistnode)+(l)*sizeof(str
uctskiplistnode*))staticintrandomsLeft;staticintrandomBits;staticstructskiplist*
skiplist_last_created;/*debugginghack*/#if1#defineCHECKLAST(sl)\do{\if((sl)->hea
der->forward[0]&&!(sl)->last)\assert(0);\if(!(sl)->header->forward[0]&&(sl)->las
t)\assert(0);\}while(0)#else#defineCHECKLAST(sl)#endifstaticintrandomLevel(){reg
isterintlevel=0;registerintb;do{if(randomsLeft<=0){randomBits=random();randomsLe
ft=BitsInRandom/2;}b=randomBits&3;randomBits>>=2;--randomsLeft;if(!b){level++;if
(level>=MaxLevel)returnMaxLevel;}}while(!b);returnlevel;}staticintdefault_cmp(vo
id*key1,void*key2){if(key1<key2)return-1;if(key1>key2)return1;return0;}unsignedi
ntskiplist_count(structskiplist*l){returnl->count;}structskiplist*skiplist_new(i
ntflags,int(*cmp)(void*key1,void*key2),void(*del)(void*val)){structskiplist*new;
new=XCALLOC(MTYPE_SKIP_LIST,sizeof(structskiplist));assert(new);new->level=0;new
->count=0;new->header=newNodeOfLevel(MaxNumberOfLevels);new->stats=newNodeOfLeve
l(MaxNumberOfLevels);new->flags=flags;if(cmp)new->cmp=cmp;elsenew->cmp=default_c
mp;if(del)new->del=del;skiplist_last_created=new;/*debug*/returnnew;}voidskiplis
t_free(structskiplist*l){registerstructskiplistnode*p,*q;p=l->header;do{q=p->for
ward[0];if(l->del&&p!=l->header)(*l->del)(p->value);XFREE(MTYPE_SKIP_LIST_NODE,p
);p=q;}while(p);XFREE(MTYPE_SKIP_LIST_NODE,l->stats);XFREE(MTYPE_SKIP_LIST,l);}i
ntskiplist_insert(registerstructskiplist*l,registervoid*key,registervoid*value){
registerintk;structskiplistnode*update[MaxNumberOfLevels];registerstructskiplist
node*p,*q;CHECKLAST(l);/*DEBUG*/if(!key){zlog_err("%s:keyis0,valueis%p",__func__
,value);}p=l->header;k=l->level;do{while(q=p->forward[k],q&&(*l->cmp)(q->key,key
)<0)p=q;update[k]=p;}while(--k>=0);if(!(l->flags&SKIPLIST_FLAG_ALLOW_DUPLICATES)
&&q&&((*l->cmp)(q->key,key)==0)){return-1;}k=randomLevel();if(k>l->level){k=++l-
>level;update[k]=l->header;}q=newNodeOfLevel(k);q->key=key;q->value=value;#ifSKI
PLIST_0TIMER_DEBUGq->flags=SKIPLIST_NODE_FLAG_INSERTED;/*debug*/#endif++(l->stat
s->forward[k]);#ifSKIPLIST_DEBUGzlog_debug("%s:incrementedstats@%p:%d,now%ld",__
func__,l,k,l->stats->forward[k]-(structskiplistnode*)NULL);#endifdo{p=update[k];
q->forward[k]=p->forward[k];p->forward[k]=q;}while(--k>=0);/**Ifthisisthelastite
minthelist,updatethe"last"pointer*/if(!q->forward[0]){l->last=q;}++(l->count);CH
ECKLAST(l);return0;}intskiplist_delete(registerstructskiplist*l,registervoid*key
,registervoid*value)/*usedonlyifduplicatesallowed*/{registerintk,m;structskiplis
tnode*update[MaxNumberOfLevels];registerstructskiplistnode*p,*q;CHECKLAST(l);/*t
omakedebuggingeasier*/for(k=0;k<MaxNumberOfLevels;++k)update[k]=NULL;p=l->header
;k=m=l->level;do{while(q=p->forward[k],q&&(*l->cmp)(q->key,key)<0)p=q;update[k]=
p;}while(--k>=0);if(l->flags&SKIPLIST_FLAG_ALLOW_DUPLICATES){while(q&&((*l->cmp)
(q->key,key)==0)&&(q->value!=value)){inti;for(i=0;i<=l->level;++i){if(update[i]-
>forward[i]==q)update[i]=q;}q=q->forward[0];}}if(q&&(*l->cmp)(q->key,key)==0){if
(!(l->flags&SKIPLIST_FLAG_ALLOW_DUPLICATES)||(q->value==value)){/**foundnodetode
lete*/#ifSKIPLIST_0TIMER_DEBUGq->flags&=~SKIPLIST_NODE_FLAG_INSERTED;#endif/**If
wearedeletingthelastelementofthelist,*updatethelist's"last"pointer.*/if(l->last=
=q){if(update[0]==l->header)l->last=NULL;elsel->last=update[0];}for(k=0;k<=m&&(p
=update[k])->forward[k]==q;k++){p->forward[k]=q->forward[k];}--(l->stats->forwar
d[k-1]);#ifSKIPLIST_DEBUGzlog_debug("%s:decrementedstats@%p:%d,now%ld",__func__,
l,k-1,l->stats->forward[k-1]-(structskiplistnode*)NULL);#endifif(l->del)(*l->del
)(q->value);XFREE(MTYPE_SKIP_LIST_NODE,q);while(l->header->forward[m]==NULL&&m>0
)m--;l->level=m;CHECKLAST(l);--(l->count);return0;}}CHECKLAST(l);return-1;}/**Ob
tainfirstvaluematching"key".UnlessSKIPLIST_FLAG_ALLOW_DUPLICATES*isset,thiswilla
lsobetheonlyvaluematching"key".**Alsosetacursorforusewithskiplist_next_value.*/i
ntskiplist_first_value(registerstructskiplist*l,/*in*/registervoid*key,/*in*/voi
d**valuePointer,/*out*/void**cursor)/*out*/{registerintk;registerstructskiplistn
ode*p,*q;p=l->header;k=l->level;do{while(q=p->forward[k],q&&(*l->cmp)(q->key,key
)<0)p=q;}while(--k>=0);if(!q||(*l->cmp)(q->key,key))return-1;if(valuePointer)*va
luePointer=q->value;if(cursor)*cursor=q;return0;}intskiplist_search(registerstru
ctskiplist*l,registervoid*key,void**valuePointer){returnskiplist_first_value(l,k
ey,valuePointer,NULL);}/**Callersupplieskeyandvalueofanexistingiteminthelist.*Fu
nctionreturnsthevalueofthenextlistitemthathasthe*samekey(usefulwhenSKIPLIST_FLAG
_ALLOW_DUPLICATESisset).**Returns0onsuccess.Ifthecaller-suppliedkeyandvalue*dono
tcorrespondtoalistelement,oriftheyspecifythe*lastelementwiththegivenkey,-1isretu
rned.*/intskiplist_next_value(registerstructskiplist*l,/*in*/registervoid*key,/*
in*/void**valuePointer,/*in/out*/void**cursor)/*in/out*/{registerintk,m;register
structskiplistnode*p,*q;CHECKLAST(l);if(!(l->flags&SKIPLIST_FLAG_ALLOW_DUPLICATE
S)){return-1;}if(!cursor||!*cursor){p=l->header;k=m=l->level;/**Findmatchingkey*
/do{while(q=p->forward[k],q&&(*l->cmp)(q->key,key)<0)p=q;}while(--k>=0);/**Findm
atchingvalue*/while(q&&((*l->cmp)(q->key,key)==0)&&(q->value!=*valuePointer)){q=
q->forward[0];}if(!q||((*l->cmp)(q->key,key)!=0)||(q->value!=*valuePointer)){/**
Nomatchingvalue*/CHECKLAST(l);return-1;}}else{q=(structskiplistnode*)*cursor;}/*
*Advancecursor*/q=q->forward[0];/**Ifwereachedend-of-listorifthekeyisnolongerthe
same,*thenreturnerror*/if(!q||((*l->cmp)(q->key,key)!=0))return-1;*valuePointer=
q->value;if(cursor)*cursor=q;CHECKLAST(l);return0;}intskiplist_first(registerstr
uctskiplist*l,void**keyPointer,void**valuePointer){registerstructskiplistnode*p;
CHECKLAST(l);p=l->header->forward[0];if(!p)return-1;if(keyPointer)*keyPointer=p-
>key;if(valuePointer)*valuePointer=p->value;CHECKLAST(l);return0;}intskiplist_la
st(registerstructskiplist*l,void**keyPointer,void**valuePointer){CHECKLAST(l);if
(l->last){if(keyPointer)*keyPointer=l->last->key;if(valuePointer)*valuePointer=l
->last->value;return0;}return-1;}/**true=empty*/intskiplist_empty(registerstruct
skiplist*l){CHECKLAST(l);if(l->last)return0;return1;}/**Usethistowalkthelist.Cal
lersets*cursortoNULLtoobtain*firstelement.Returnvalueof0indicatesvalidcursor/ele
ment*returned,otherwiseNULLcursorargorEOL.*/intskiplist_next(registerstructskipl
ist*l,/*in*/void**keyPointer,/*out*/void**valuePointer,/*out*/void**cursor)/*in/
out*/{structskiplistnode*p;if(!cursor)return-1;CHECKLAST(l);if(!*cursor){p=l->he
ader->forward[0];}else{p=*cursor;p=p->forward[0];}*cursor=p;if(!p)return-1;if(ke
yPointer)*keyPointer=p->key;if(valuePointer)*valuePointer=p->value;CHECKLAST(l);
return0;}intskiplist_delete_first(registerstructskiplist*l){registerintk;registe
rstructskiplistnode*p,*q;intnodelevel=0;CHECKLAST(l);p=l->header;q=l->header->fo
rward[0];if(!q)return-1;for(k=l->level;k>=0;--k){if(p->forward[k]==q){p->forward
[k]=q->forward[k];if((k==l->level)&&(p->forward[k]==NULL)&&(l->level>0))--(l->le
vel);if(!nodelevel)nodelevel=k;}}#ifSKIPLIST_0TIMER_DEBUGq->flags&=~SKIPLIST_NOD
E_FLAG_INSERTED;#endif/**Ifwearedeletingthelastelementofthelist,*updatethelist's
"last"pointer.*/if(l->last==q){l->last=NULL;}--(l->stats->forward[nodelevel]);#i
fSKIPLIST_DEBUGzlog_debug("%s:decrementedstats@%p:%d,now%ld",__func__,l,nodeleve
l,l->stats->forward[nodelevel]-(structskiplistnode*)NULL);#endifif(l->del)(*l->d
el)(q->value);XFREE(MTYPE_SKIP_LIST_NODE,q);CHECKLAST(l);--(l->count);return0;}v
oidskiplist_debug(structvty*vty,structskiplist*l){inti;if(!l)l=skiplist_last_cre
ated;vty_out(vty,"Skiplist%phasmaxlevel%d\n",l,l->level);for(i=l->level;i>=0;--i
)vty_out(vty,"@%d:%ld\n",i,(long)((l->stats->forward[i])-(structskiplistnode*)NU
LL));}staticvoid*scramble(inti){uintptr_tresult;result=(unsigned)(i&0xff)<<24;re
sult|=(unsigned)i>>8;return(void*)result;}#definesampleSize65536voidskiplist_tes
t(structvty*vty){structskiplist*l;registerinti,k;void*keys[sampleSize];void*v;zl
og_debug("%s:entry",__func__);l=skiplist_new(SKIPLIST_FLAG_ALLOW_DUPLICATES,NULL
,NULL);zlog_debug("%s:skiplist_newreturned%p",__func__,l);for(i=0;i<4;i++){for(k
=0;k<sampleSize;k++){if(!(k%1000)){zlog_debug("%s:(%d:%d)",__func__,i,k);}//keys
[k]=(void*)random();keys[k]=(void*)scramble(k);if(skiplist_insert(l,keys[k],keys
[k]))zlog_debug("errorininsert#%d,#%d",i,k);}zlog_debug("%s:insertsdone",__func_
_);for(k=0;k<sampleSize;k++){if(!(k%1000))zlog_debug("[%d:%d]",i,k);if(skiplist_
search(l,keys[k],&v))zlog_debug("errorinsearch#%d,#%d",i,k);if(v!=keys[k])zlog_d
ebug("searchreturnedwrongvalue");}for(k=0;k<sampleSize;k++){if(!(k%1000))zlog_de
bug("<%d:%d>",i,k);if(skiplist_delete(l,keys[k],keys[k]))zlog_debug("errorindele
te");keys[k]=(void*)scramble(k^0xf0f0f0f0);if(skiplist_insert(l,keys[k],keys[k])
)zlog_debug("errorininsert#%d,#%d",i,k);}for(k=0;k<sampleSize;k++){if(!(k%1000))
zlog_debug("{%d:%d}",i,k);if(skiplist_delete_first(l))zlog_debug("errorindelete_
first");}}skiplist_free(l);}