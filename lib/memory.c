/**Copyright(c)2015-16DavidLamparter,forNetDEF,Inc.**Permissiontouse,copy,modify
,anddistributethissoftwareforany*purposewithorwithoutfeeisherebygranted,provided
thattheabove*copyrightnoticeandthispermissionnoticeappearinallcopies.**THESOFTWA
REISPROVIDED"ASIS"ANDTHEAUTHORDISCLAIMSALLWARRANTIES*WITHREGARDTOTHISSOFTWAREINC
LUDINGALLIMPLIEDWARRANTIESOF*MERCHANTABILITYANDFITNESS.INNOEVENTSHALLTHEAUTHORBE
LIABLEFOR*ANYSPECIAL,DIRECT,INDIRECT,ORCONSEQUENTIALDAMAGESORANYDAMAGES*WHATSOEV
ERRESULTINGFROMLOSSOFUSE,DATAORPROFITS,WHETHERINAN*ACTIONOFCONTRACT,NEGLIGENCEOR
OTHERTORTIOUSACTION,ARISINGOUTOF*ORINCONNECTIONWITHTHEUSEORPERFORMANCEOFTHISSOFT
WARE.*/#include<zebra.h>#include<stdlib.h>#include"memory.h"#include"log.h"stati
cstructmemgroup*mg_first=NULL;structmemgroup**mg_insert=&mg_first;DEFINE_MGROUP(
LIB,"libfrr")DEFINE_MTYPE(LIB,TMP,"Temporarymemory")DEFINE_MTYPE(LIB,PREFIX_FLOW
SPEC,"PrefixFlowspec")staticinlinevoidmt_count_alloc(structmemtype*mt,size_tsize
){size_toldsize;atomic_fetch_add_explicit(&mt->n_alloc,1,memory_order_relaxed);o
ldsize=atomic_load_explicit(&mt->size,memory_order_relaxed);if(oldsize==0)oldsiz
e=atomic_exchange_explicit(&mt->size,size,memory_order_relaxed);if(oldsize!=0&&o
ldsize!=size&&oldsize!=SIZE_VAR)atomic_store_explicit(&mt->size,SIZE_VAR,memory_
order_relaxed);}staticinlinevoidmt_count_free(structmemtype*mt){assert(mt->n_all
oc);atomic_fetch_sub_explicit(&mt->n_alloc,1,memory_order_relaxed);}staticinline
void*mt_checkalloc(structmemtype*mt,void*ptr,size_tsize){if(__builtin_expect(ptr
==NULL,0)){memory_oom(size,mt->name);returnNULL;}mt_count_alloc(mt,size);returnp
tr;}void*qmalloc(structmemtype*mt,size_tsize){returnmt_checkalloc(mt,malloc(size
),size);}void*qcalloc(structmemtype*mt,size_tsize){returnmt_checkalloc(mt,calloc
(size,1),size);}void*qrealloc(structmemtype*mt,void*ptr,size_tsize){if(ptr)mt_co
unt_free(mt);returnmt_checkalloc(mt,ptr?realloc(ptr,size):malloc(size),size);}vo
id*qstrdup(structmemtype*mt,constchar*str){returnmt_checkalloc(mt,strdup(str),st
rlen(str)+1);}voidqfree(structmemtype*mt,void*ptr){if(ptr)mt_count_free(mt);free
(ptr);}intqmem_walk(qmem_walk_fn*func,void*arg){structmemgroup*mg;structmemtype*
mt;intrv;for(mg=mg_first;mg;mg=mg->next){if((rv=func(arg,mg,NULL)))returnrv;for(
mt=mg->types;mt;mt=mt->next)if((rv=func(arg,mg,mt)))returnrv;}return0;}structexi
t_dump_args{FILE*fp;constchar*prefix;interror;};staticintqmem_exit_walker(void*a
rg,structmemgroup*mg,structmemtype*mt){structexit_dump_args*eda=arg;if(!mt){fpri
ntf(eda->fp,"%s:showingactiveallocationsin""memorygroup%s\n",eda->prefix,mg->nam
e);}elseif(mt->n_alloc){charsize[32];eda->error++;snprintf(size,sizeof(size),"%1
0zu",mt->size);fprintf(eda->fp,"%s:memstats:%-30s:%6zu*%s\n",eda->prefix,mt->nam
e,mt->n_alloc,mt->size==SIZE_VAR?"(variablysized)":size);}return0;}intlog_memsta
ts(FILE*fp,constchar*prefix){structexit_dump_argseda={.fp=fp,.prefix=prefix,.err
or=0};qmem_walk(qmem_exit_walker,&eda);returneda.error;}