/*
 * Copyright (c) 2021-22  David Lamparter, for NetDEF, Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* note: dbg() is in zlog.h, this is only the DEFINE_DEBUGFLAG_* stuff */

#ifndef _FRR_ZLOG_DEBUG_H
#define _FRR_ZLOG_DEBUG_H

#include <stdint.h>

#include "frratomic.h"
#include "typesafe.h"

#ifdef __cplusplus
extern "C" {
#endif

struct vty;
struct cmd_token;
struct cmd_element;

/* whether flag was added in config mode or enable mode
 * used for "fl_*" fields
 */
#define LOGMSG_FLAG_EPHEMERAL	(1 << 0)
#define LOGMSG_FLAG_PERSISTENT	(1 << 1)

PREDECL_RBTREE_UNIQ(zlog_debugflags);
PREDECL_LIST(zlog_debugflag_combos);

enum zlog_debugflag_kind {
	ZDF_PLAIN = 0,
	ZDF_COMBO,
};

struct zlog_debugflag {
	union {
		atomic_uint_fast32_t fl_enable;
		void *_platform_indep_pad;
	};

	const char *code_name;

	enum zlog_debugflag_kind kind;

	int _pad0;
};

#define dbg_check(zdf) (_dbg_##zdf->common.fl_enable && _dbg_filter_##zdf)

/*
 * basic debug flag, autogenerated CLI
 */

/* struct also used for parametrized debug flags */
struct zlog_debugflag_plain {
	struct zlog_debugflag common;

	const char *cli_name;
	const char *params;
	const struct cmd_element *cmd;

	void (*enable)(bool enabled);

	struct zlog_debugflags_item zdf_item;
	struct zlog_debugflag_combos_head combos[1];
};

extern void zlog_debugflag_plain_register(struct zlog_debugflag_plain *zdf);

#define DECLARE_DEBUGFLAG(name)                                                \
	extern struct zlog_debugflag_plain _dbg_##name[1];                     \
	static const bool _dbg_filter_##name __attribute__((unused)) = true;   \
	MACRO_REQUIRE_SEMICOLON()

/* DEFPY cannot be used inside macros; clippy does not expand them */
#define _DEFINE_DEBUGFLAG(qual, name, cli_name_, cli_help, ...)                \
	DEFUN(_dbg_cmdfn_##name,                                               \
	      _dbg_cmd_##name,                                                 \
	      "[no] debug " cli_name_,                                         \
	      NO_STR                                                           \
	      DEBUG_STR                                                        \
	      cli_help)                                                        \
	{                                                                      \
		return zlog_debugflag_cli(_dbg_##name, vty, argc, argv);       \
	}                                                                      \
	qual struct zlog_debugflag_plain _dbg_##name[1] = {                    \
		{                                                              \
			.common = {                                            \
				.code_name = #name,                            \
				.kind = ZDF_PLAIN,                             \
			},                                                     \
			.cli_name = cli_name_,                                 \
			.cmd = &_dbg_cmd_##name,                               \
			__VA_ARGS__                                            \
		},                                                             \
	};                                                                     \
	__attribute__((_CONSTRUCTOR(1200)))                                    \
	static void _dbg_init_##name(void)                                     \
	{                                                                      \
		zlog_debugflag_plain_register(_dbg_##name);                    \
		if (0) { /* trick vtysh/extract.pl */                          \
			install_element(ENABLE_NODE, &_dbg_cmd_##name);        \
			install_element(CONFIG_NODE, &_dbg_cmd_##name);        \
		}                                                              \
	};                                                                     \
	MACRO_REQUIRE_SEMICOLON()

#define DEFINE_DEBUGFLAG(name, cli_name_, cli_help, ...)                       \
	_DEFINE_DEBUGFLAG(, name, cli_name_, cli_help, ##__VA_ARGS__)
#define DEFINE_DEBUGFLAG_STATIC(name, cli_name_, cli_help, ...)                \
	static struct zlog_debugflag_plain _dbg_##name[1];                     \
	static const bool _dbg_filter_##name __attribute__((unused)) = true;   \
	_DEFINE_DEBUGFLAG(static, name, cli_name_, cli_help, ##__VA_ARGS__)

/*
 * parametrized version, for use like:
 *   dbg(SHARP_ROUTE(prefix), "%pFX: foobar", prefix);
 * with a function
 *   bool _dbg_filter_SHARP_ROUTE(const struct prefix *prefix) { ... }
 * that conditionally enables debug messages for a particular prefix
 */

#define DECLARE_DEBUGFLAG_PARAMS(name, params)                                 \
	extern struct zlog_debugflag_plain _dbg_##name[1];                     \
	extern bool _dbg_filter_##name params;                                 \
	MACRO_REQUIRE_SEMICOLON()

/* you need to define your own CLI command for _PARAMS */
#define _DEFINE_DEBUGFLAG_PARAMS(qual, name, cli_name_, params_)               \
	qual struct zlog_debugflag_plain _dbg_##name[1] = {                    \
		{                                                              \
			.common = {                                            \
				.code_name = #name,                            \
				.kind = ZDF_PLAIN,                             \
			},                                                     \
			.cli_name = cli_name_,                                 \
			.params = #params_,                                    \
		},                                                             \
	};                                                                     \
	__attribute__((_CONSTRUCTOR(1200)))                                    \
	static void _dbg_init_##name(void)                                     \
	{                                                                      \
		zlog_debugflag_plain_register(_dbg_##name);                    \
	};                                                                     \
	MACRO_REQUIRE_SEMICOLON()

#define DEFINE_DEBUGFLAG_PARAMS(name, cli_name_, params_)                      \
	_DEFINE_DEBUGFLAG_PARAMS(, name, cli_name_, params_)
#define DEFINE_DEBUGFLAG_PARAMS_STATIC(name, cli_name_, params_)               \
	static struct zlog_debugflag_plain _dbg_##name[1];                     \
	static bool _dbg_filter_##name params;                                 \
	_DEFINE_DEBUGFLAG_PARAMS(static, name, cli_name_, params_)

/* "COMBO" flag: A || B || ... */

struct zlog_debugflag_comboitem;

struct zlog_debugflag_combo {
	struct zlog_debugflag common;

	unsigned enable_counter;

	struct zlog_debugflag_comboitem *combo_arr;
	size_t combo_size;
};

struct zlog_debugflag_comboitem {
	struct zlog_debugflag_plain *flag;
	struct zlog_debugflag_combo *combo;
	struct zlog_debugflag_combos_item item;
};

extern void zlog_debugflag_combo_register(struct zlog_debugflag_combo *zdf);

#define DECLARE_DEBUGFLAG_COMBO(name)                                          \
	extern struct zlog_debugflag_combo _dbg_##name[1];                     \
	static const bool _dbg_filter_##name __attribute__((unused)) = true;   \
	MACRO_REQUIRE_SEMICOLON()

#define _DEBUGFLAG_COMBOITEM(flag_) { .flag = _dbg_##flag_, },

#define _DEFINE_DEBUGFLAG_COMBO(qual, name, ...)                               \
	struct zlog_debugflag_comboitem _dbgcombo_##name[] = {                 \
		MACRO_REPEAT(_DEBUGFLAG_COMBOITEM, __VA_ARGS__)                \
	};                                                                     \
	struct zlog_debugflag_combo _dbg_##name[1] = {                         \
		{                                                              \
			.common = {                                            \
				.code_name = #name,                            \
				.kind = ZDF_COMBO,                             \
			},                                                     \
			.combo_arr = _dbgcombo_##name,                         \
			.combo_size = array_size(_dbgcombo_##name),            \
		},                                                             \
	};                                                                     \
	__attribute__((_CONSTRUCTOR(1200)))                                    \
	static void _dbg_init_##name(void)                                     \
	{                                                                      \
		zlog_debugflag_combo_register(_dbg_##name);                    \
	};                                                                     \
	MACRO_REQUIRE_SEMICOLON()

#define DEFINE_DEBUGFLAG_COMBO(name, ...)                                      \
	_DEFINE_DEBUGFLAG_COMBO(, name, ##__VA_ARGS__)
#define DEFINE_DEBUGFLAG_COMBO_STATIC(name, ...)                               \
	static struct zlog_debugflag_combo _dbg_##name[1];                     \
	static const bool _dbg_filter_##name __attribute__((unused)) = true;   \
	_DEFINE_DEBUGFLAG_COMBO(static, name, ##__VA_ARGS__)

extern int zlog_debugflag_cli(struct zlog_debugflag_plain *zdf, struct vty *vty,
			       int argc, struct cmd_token *argv[]);

extern void zlog_debug_init_cmd(void);

#ifdef __cplusplus
}
#endif

#endif /* _FRR_ZLOG_DEBUG_H */
