/*Stream/packetbufferAPIimplementation*Copyright(c)2014-2015TimoTer√§s**Thisfilei
sfreesoftware:youmaycopy,redistributeand/ormodify*itunderthetermsoftheGNUGeneral
PublicLicenseaspublishedby*theFreeSoftwareFoundation,eitherversion2oftheLicense,
or*(atyouroption)anylaterversion.*/#define_GNU_SOURCE#include<string.h>#include<
unistd.h>#include<errno.h>#include"zassert.h"#include"zbuf.h"#include"memory.h"#
include"nhrpd.h"#defineERRNO_IO_RETRY(EN)(((EN)==EAGAIN)||((EN)==EWOULDBLOCK)||(
(EN)==EINTR))DEFINE_MTYPE_STATIC(NHRPD,ZBUF_DATA,"NHRPDzbufdata")structzbuf*zbuf
_alloc(size_tsize){structzbuf*zb;zb=XMALLOC(MTYPE_ZBUF_DATA,sizeof(*zb)+size);if
(!zb)returnNULL;zbuf_init(zb,zb+1,size,0);zb->allocated=1;returnzb;}voidzbuf_ini
t(structzbuf*zb,void*buf,size_tlen,size_tdatalen){*zb=(structzbuf){.buf=buf,.end
=(uint8_t*)buf+len,.head=buf,.tail=(uint8_t*)buf+datalen,};}voidzbuf_free(struct
zbuf*zb){if(zb->allocated)XFREE(MTYPE_ZBUF_DATA,zb);}voidzbuf_reset(structzbuf*z
b){zb->head=zb->tail=zb->buf;zb->error=0;}voidzbuf_reset_head(structzbuf*zb,void
*ptr){zassert((void*)zb->buf<=ptr&&ptr<=(void*)zb->tail);zb->head=ptr;}staticvoi
dzbuf_remove_headroom(structzbuf*zb){ssize_theadroom=zbuf_headroom(zb);if(!headr
oom)return;memmove(zb->buf,zb->head,zbuf_used(zb));zb->head-=headroom;zb->tail-=
headroom;}ssize_tzbuf_read(structzbuf*zb,intfd,size_tmaxlen){ssize_tr;if(zb->err
or)return-3;zbuf_remove_headroom(zb);if(maxlen>zbuf_tailroom(zb))maxlen=zbuf_tai
lroom(zb);r=read(fd,zb->tail,maxlen);if(r>0)zb->tail+=r;elseif(r==0)r=-2;elseif(
r<0&&ERRNO_IO_RETRY(errno))r=0;returnr;}ssize_tzbuf_write(structzbuf*zb,intfd){s
size_tr;if(zb->error)return-3;r=write(fd,zb->head,zbuf_used(zb));if(r>0){zb->hea
d+=r;if(zb->head==zb->tail)zbuf_reset(zb);}elseif(r==0)r=-2;elseif(r<0&&ERRNO_IO
_RETRY(errno))r=0;returnr;}ssize_tzbuf_recv(structzbuf*zb,intfd){ssize_tr;if(zb-
>error)return-3;zbuf_remove_headroom(zb);r=recv(fd,zb->tail,zbuf_tailroom(zb),0)
;if(r>0)zb->tail+=r;elseif(r==0)r=-2;elseif(r<0&&ERRNO_IO_RETRY(errno))r=0;retur
nr;}ssize_tzbuf_send(structzbuf*zb,intfd){ssize_tr;if(zb->error)return-3;r=send(
fd,zb->head,zbuf_used(zb),0);if(r>=0)zbuf_reset(zb);returnr;}void*zbuf_may_pull_
until(structzbuf*zb,constchar*sep,structzbuf*msg){size_tseplen=strlen(sep),len;u
int8_t*ptr;ptr=memmem(zb->head,zbuf_used(zb),sep,seplen);if(!ptr)returnNULL;len=
ptr-zb->head+seplen;zbuf_init(msg,zbuf_pulln(zb,len),len,len);returnmsg->head;}v
oidzbufq_init(structzbuf_queue*zbq){*zbq=(structzbuf_queue){.queue_head=LIST_INI
TIALIZER(zbq->queue_head),};}voidzbufq_reset(structzbuf_queue*zbq){structzbuf*bu
f,*bufn;list_for_each_entry_safe(buf,bufn,&zbq->queue_head,queue_list){list_del(
&buf->queue_list);zbuf_free(buf);}}voidzbufq_queue(structzbuf_queue*zbq,structzb
uf*zb){list_add_tail(&zb->queue_list,&zbq->queue_head);}intzbufq_write(structzbu
f_queue*zbq,intfd){structioveciov[16];structzbuf*zb,*zbn;ssize_tr;size_tiovcnt=0
;list_for_each_entry_safe(zb,zbn,&zbq->queue_head,queue_list){iov[iovcnt++]=(str
uctiovec){.iov_base=zb->head,.iov_len=zbuf_used(zb),};if(iovcnt>=ZEBRA_NUM_OF(io
v))break;}r=writev(fd,iov,iovcnt);if(r<0)returnr;list_for_each_entry_safe(zb,zbn
,&zbq->queue_head,queue_list){if(r<(ssize_t)zbuf_used(zb)){zb->head+=r;return1;}
r-=zbuf_used(zb);list_del(&zb->queue_list);zbuf_free(zb);}return0;}voidzbuf_copy
(structzbuf*zdst,structzbuf*zsrc,size_tlen){constvoid*src;void*dst;dst=zbuf_push
n(zdst,len);src=zbuf_pulln(zsrc,len);if(!dst||!src)return;memcpy(dst,src,len);}