/*Linuxkernelstylelisthandlingfunction**WrittenfromscratchbyTimoTer√§s<timo.teras
@iki.fi>,butmodeled*afterthelinuxkernelcode.**Thisfileisfreesoftware:youmaycopy,
redistributeand/ormodify*itunderthetermsoftheGNUGeneralPublicLicenseaspublishedb
y*theFreeSoftwareFoundation,eitherversion2oftheLicense,or*(atyouroption)anylater
version.*/#ifndefLIST_H#defineLIST_H#ifndefNULL#defineNULL0L#endif#ifndefoffseto
f#ifdef__compiler_offsetof#defineoffsetof(TYPE,MEMBER)__compiler_offsetof(TYPE,M
EMBER)#else#defineoffsetof(TYPE,MEMBER)((size_t)&((TYPE*)0)->MEMBER)#endif#endif
#ifndefcontainer_of#definecontainer_of(ptr,type,member)\({\consttypeof(((type*)0
)->member)*__mptr=(ptr);\(type*)((char*)__mptr-offsetof(type,member));\})#endifs
tructhlist_head{structhlist_node*first;};structhlist_node{structhlist_node*next;
structhlist_node**pprev;};staticinlineinthlist_empty(conststructhlist_head*h){re
turn!h->first;}staticinlineinthlist_hashed(conststructhlist_node*n){returnn->ppr
ev!=NULL;}staticinlinevoidhlist_del(structhlist_node*n){structhlist_node*next=n-
>next;structhlist_node**pprev=n->pprev;*pprev=next;if(next)next->pprev=pprev;n->
next=NULL;n->pprev=NULL;}staticinlinevoidhlist_add_head(structhlist_node*n,struc
thlist_head*h){structhlist_node*first=h->first;n->next=first;if(first)first->ppr
ev=&n->next;n->pprev=&h->first;h->first=n;}staticinlinevoidhlist_add_after(struc
thlist_node*n,structhlist_node*prev){n->next=prev->next;n->pprev=&prev->next;pre
v->next=n;}staticinlinestructhlist_node**hlist_tail_ptr(structhlist_head*h){stru
cthlist_node*n=h->first;if(n==NULL)return&h->first;while(n->next!=NULL)n=n->next
;return&n->next;}#definehlist_entry(ptr,type,member)container_of(ptr,type,member
)#definehlist_for_each(pos,head)\for(pos=(head)->first;pos;pos=pos->next)#define
hlist_for_each_safe(pos,n,head)\for(pos=(head)->first;pos&&({\n=pos->next;\1;\})
;\pos=n)#definehlist_for_each_entry(tpos,pos,head,member)\for(pos=(head)->first;
\pos&&({\tpos=hlist_entry(pos,typeof(*tpos),member);\1;\});\pos=pos->next)#defin
ehlist_for_each_entry_safe(tpos,pos,n,head,member)\for(pos=(head)->first;\pos&&(
{\n=pos->next;\1;\})\&&({\tpos=hlist_entry(pos,typeof(*tpos),member);\1;\});\pos
=n)structlist_head{structlist_head*next,*prev;};#defineLIST_INITIALIZER(l){.next
=&l,.prev=&l}staticinlinevoidlist_init(structlist_head*list){list->next=list;lis
t->prev=list;}staticinlinevoid__list_add(structlist_head*new,structlist_head*pre
v,structlist_head*next){next->prev=new;new->next=next;new->prev=prev;prev->next=
new;}staticinlinevoidlist_add(structlist_head*new,structlist_head*head){__list_a
dd(new,head,head->next);}staticinlinevoidlist_add_tail(structlist_head*new,struc
tlist_head*head){__list_add(new,head->prev,head);}staticinlinevoid__list_del(str
uctlist_head*prev,structlist_head*next){next->prev=prev;prev->next=next;}statici
nlinevoidlist_del(structlist_head*entry){__list_del(entry->prev,entry->next);ent
ry->next=NULL;entry->prev=NULL;}staticinlineintlist_hashed(conststructlist_head*
n){returnn->next!=n&&n->next!=NULL;}staticinlineintlist_empty(conststructlist_he
ad*n){return!list_hashed(n);}#definelist_next(ptr,type,member)\(list_hashed(ptr)
?container_of((ptr)->next,type,member):NULL)#definelist_entry(ptr,type,member)co
ntainer_of(ptr,type,member)#definelist_for_each(pos,head)\for(pos=(head)->next;p
os!=(head);pos=pos->next)#definelist_for_each_safe(pos,n,head)\for(pos=(head)->n
ext,n=pos->next;pos!=(head);\pos=n,n=pos->next)#definelist_for_each_entry(pos,he
ad,member)\for(pos=list_entry((head)->next,typeof(*pos),member);\&pos->member!=(
head);\pos=list_entry(pos->member.next,typeof(*pos),member))#definelist_for_each
_entry_safe(pos,n,head,member)\for(pos=list_entry((head)->next,typeof(*pos),memb
er),\n=list_entry(pos->member.next,typeof(*pos),member);\&pos->member!=(head);\p
os=n,n=list_entry(n->member.next,typeof(*n),member))#endif