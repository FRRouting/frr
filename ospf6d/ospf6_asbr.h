/*
 * Copyright (C) 2001 Yasuhiro Ohara
 *
 * This file is part of GNU Zebra.
 *
 * GNU Zebra is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 * GNU Zebra is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; see the file COPYING; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef OSPF6_ASBR_H
#define OSPF6_ASBR_H

/* for struct ospf6_prefix */
#include "ospf6_proto.h"
/* for struct ospf6_lsa */
#include "ospf6_lsa.h"
/* for struct ospf6_route */
#include "ospf6_route.h"

/* Debug option */
extern unsigned char conf_debug_ospf6_asbr;
#define OSPF6_DEBUG_ASBR_ON() (conf_debug_ospf6_asbr = 1)
#define OSPF6_DEBUG_ASBR_OFF() (conf_debug_ospf6_asbr = 0)
#define IS_OSPF6_DEBUG_ASBR (conf_debug_ospf6_asbr)

extern unsigned char conf_debug_ospf6_summary;
#define OSPF6_DEBUG_SUMMARY_ON() (conf_debug_ospf6_summary = 1)
#define OSPF6_DEBUG_SUMMARY_OFF() (conf_debug_ospf6_summary = 0)
#define IS_OSPF6_DEBUG_SUMMARY (conf_debug_ospf6_summary)

/**
 * OSPFv3 summary address data structure.
 *
 * This structure holds information about summary address and is used to
 * suppress and/or originate a summary route.
 */
struct summary_address {
	/** Back pointer to OSPFv3 instance context. */
	struct ospf6 *ospf6;
	/** Back pointer to route node. */
	struct route_node *node;
	/** Tag for summary route. */
	route_tag_t tag;
	/** OSPFv3 route generated by summary address. */
	struct ospf6_route *route;

	/** Summary address state flags */
	uint32_t flags;
	/**
	 * Is the summary configuration deleted?
	 *
	 * A entry can be marked for deletion before it gets removed from all
	 * summarized routes.
	 */
#define SUMMARY_ADDRESS_F_DELETED (1 << 0)
	/** Is the summary route created? */
#define SUMMARY_ADDRESS_F_ORIGINATED (1 << 1)

	/**
	 * Reference count.
	 *
	 * When removing a summary address we must make sure it is not
	 * affecting an external route, so in order to do that we must
	 * keep a usage count from external routes.
	 */
	uint64_t refcount;
};

struct ospf6_external_info {
	/* External route type */
	int type;

	/* Originating Link State ID */
	uint32_t id;

	struct in6_addr forwarding;

	route_tag_t tag;

	ifindex_t ifindex;

	/**
	 * Back pointer to summary address configuration.
	 *
	 * This information is used to derive two things:
	 *  - Route is summarized.
	 *  - What configuration caused it (useful to detect more/less specific
	 *    summaries).
	 */
	struct summary_address *summary;
};

/* AS-External-LSA */
#define OSPF6_AS_EXTERNAL_LSA_MIN_SIZE         4U /* w/o IPv6 prefix */
struct ospf6_as_external_lsa {
	uint32_t bits_metric;

	struct ospf6_prefix prefix;
	/* followed by none or one forwarding address */
	/* followed by none or one external route tag */
	/* followed by none or one referenced LS-ID */
};

#define OSPF6_ASBR_BIT_T  ntohl (0x01000000)
#define OSPF6_ASBR_BIT_F  ntohl (0x02000000)
#define OSPF6_ASBR_BIT_E  ntohl (0x04000000)

#define OSPF6_ASBR_METRIC(E) (ntohl ((E)->bits_metric & htonl (0x00ffffff)))
#define OSPF6_ASBR_METRIC_SET(E, C)                                            \
	{                                                                      \
		(E)->bits_metric &= htonl(0xff000000);                         \
		(E)->bits_metric |= htonl(0x00ffffff) & htonl(C);              \
	}

/**
 * Create and add new summary address to the summary route table.
 *
 * Before calling this function you *MUST* do a `route_node_lookup` for the
 * prefix `p` to avoid having a memory leak here.
 *
 * `route_node_get` searches for a prefix and returns node if found otherwise
 * it allocates a new one. There is no function to only allocate a new
 * `struct route node` at this time.
 *
 * \param ospf6 OSPFv3 instance context.
 * \param p summary address prefix.
 * \returns summary address data structure.
 */
extern struct summary_address *summary_address_new(struct ospf6 *ospf6,
						   const struct prefix *p);

/**
 * Summary address resource free function.
 *
 * Checks for potential users and if not in use then free the resources.
 */
extern void summary_address_free(struct summary_address **sum);

/** Schedule next route summarization process. */
extern void summary_address_schedule_process(struct ospf6 *o);

/**
 * Apply summary address if configured to route.
 *
 * When this function returns `true` the code calling it should not install
 * the LSA for this summary.
 *
 * \returns `true` on existing applicable summary address otherwise `false`.
 */
extern bool summary_address_apply(struct ospf6 *ospf6,
				  struct ospf6_route *route);

extern void ospf6_asbr_lsa_add(struct ospf6_lsa *lsa);

extern void ospf6_asbr_lsa_remove(struct ospf6_lsa *lsa,
				  struct ospf6_route *asbr_entry);
extern void ospf6_asbr_lsentry_add(struct ospf6_route *asbr_entry,
				   struct ospf6 *ospf6);
extern void ospf6_asbr_lsentry_remove(struct ospf6_route *asbr_entry,
				      struct ospf6 *ospf6);

extern int ospf6_asbr_is_asbr(struct ospf6 *o);
extern void ospf6_asbr_redistribute_add(int type, ifindex_t ifindex,
					struct prefix *prefix,
					unsigned int nexthop_num,
					struct in6_addr *nexthop,
					route_tag_t tag, struct ospf6 *ospf6);
extern void ospf6_asbr_redistribute_remove(int type, ifindex_t ifindex,
					   struct prefix *prefix,
					   struct ospf6 *ospf6);

extern int ospf6_redistribute_config_write(struct vty *vty,
					   struct ospf6 *ospf6);

extern void ospf6_asbr_init(void);
extern void ospf6_asbr_redistribute_disable(struct ospf6 *ospf6);
extern void ospf6_asbr_redistribute_reset(struct ospf6 *ospf6);
extern void ospf6_asbr_terminate(void);
extern void ospf6_asbr_send_externals_to_area(struct ospf6_area *);
extern void ospf6_asbr_remove_externals_from_area(struct ospf6_area *oa);

extern int config_write_ospf6_debug_asbr(struct vty *vty);
extern int ospf6_distribute_config_write(struct vty *vty, struct ospf6 *ospf6);
extern void install_element_ospf6_debug_asbr(void);
extern void ospf6_asbr_update_route_ecmp_path(struct ospf6_route *old,
					      struct ospf6_route *route,
					      struct ospf6 *ospf6);
extern void ospf6_asbr_distribute_list_update(struct ospf6 *ospf6,
					      struct ospf6_redist *red);
struct ospf6_redist *ospf6_redist_lookup(struct ospf6 *ospf6, int type,
					 unsigned short instance);
extern void ospf6_asbr_routemap_update(const char *mapname);

/**
 * Originates a LSA for the specified route.
 *
 * Don't forget to call `summary_address_apply` before calling this function
 * otherwise it might end up generating an LSA for a summarized route.
 */
extern void ospf6_as_external_lsa_originate(struct ospf6_route *route,
					    struct ospf6 *ospf6);
extern void ospf6_asbr_status_update(struct ospf6 *ospf6, int status);

#endif /* OSPF6_ASBR_H */
