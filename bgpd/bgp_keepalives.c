/*BGPKeepalives.*ImplementsaproducerthreadtogenerateBGPkeepalivesforpeers.*Copyr
ight(C)2017CumulusNetworks,Inc.*QuentinYoung**ThisfileispartofFRRouting.**FRRout
ingisfreesoftware;youcanredistributeitand/ormodifyitunder*thetermsoftheGNUGenera
lPublicLicenseaspublishedbytheFree*SoftwareFoundation;eitherversion2,or(atyourop
tion)anylater*version.**FRRoutingisdistributedinthehopethatitwillbeuseful,butWIT
HOUTANY*WARRANTY;withouteventheimpliedwarrantyofMERCHANTABILITYorFITNESS*FORAPAR
TICULARPURPOSE.SeetheGNUGeneralPublicLicenseformore*details.**Youshouldhaverecei
vedacopyoftheGNUGeneralPublicLicensealong*withthisprogram;seethefileCOPYING;ifno
t,writetotheFreeSoftware*Foundation,Inc.,51FranklinSt,FifthFloor,Boston,MA02110-
1301USA*//*clang-formatoff*/#include<zebra.h>#include<pthread.h>//forpthread_mut
ex_lock,pthread_mutex_unlock#include"frr_pthread.h"//forfrr_pthread#include"hash
.h"//forhash,hash_clean,hash_create_size...#include"log.h"//forzlog_debug#includ
e"memory.h"//forMTYPE_TMP,XFREE,XCALLOC,XMALLOC#include"monotime.h"//formonotime
,monotime_since#include"bgpd/bgpd.h"//forpeer,PEER_THREAD_KEEPALIVES_ON,peer...#
include"bgpd/bgp_debug.h"//forbgp_debug_neighbor_events#include"bgpd/bgp_packet.
h"//forbgp_keepalive_send#include"bgpd/bgp_keepalives.h"/*clang-formaton*//**Pee
rKeepAliveTimer.*Associatesapeerwiththetimeofitslastkeepalive.*/structpkat{/*the
peertosendkeepalivesto*/structpeer*peer;/*absolutetimeoflastkeepalivesent*/struc
ttimevallast;};/*Listofpeerswearesendingkeepalivesfor,andassociatedmutex.*/stati
cpthread_mutex_t*peerhash_mtx;staticpthread_cond_t*peerhash_cond;staticstructhas
h*peerhash;staticstructpkat*pkat_new(structpeer*peer){structpkat*pkat=XMALLOC(MT
YPE_TMP,sizeof(structpkat));pkat->peer=peer;monotime(&pkat->last);returnpkat;}st
aticvoidpkat_del(void*pkat){XFREE(MTYPE_TMP,pkat);}/**Callbackforhash_iterate.De
terminesifapeerneedsakeepaliveandifso,*generatesandsendsit.**Foranygivenpeer,ift
heelapsedtimesinceitslastkeepaliveexceedsits*configuredkeepalivetimer,akeepalive
issenttothepeerandits*last-senttimeisreset.Additionally,Iftheelapsedtimedoesnote
xceed*theconfiguredkeepalivetimer,butthetimeuntilthenextkeepaliveisdue*iswithina
hardcodedtolerance,akeepaliveissentasiftheconfigured*timerwasexceeded.Doingthish
elpsalleviatenanosecondsleepsbetween*ticksbygroupingtogetherpeerswhoaredueforkee
palivesatroughlythe*sametime.Thistolerancevalueisarbitrarilychosentobe100ms.**In
addition,thisfunctioncalculatesthemaximumamountoftimethatthe*keepalivethreadcans
leepbeforeanothertickneedstotakeplace.Thisis*equivalenttoshortesttimeuntilakeepa
liveisdueforanyonepeer.**@returnmaximumtimetowaituntilnextupdate(0ifinfinity)*/s
taticvoidpeer_process(structhash_backet*hb,void*arg){structpkat*pkat=hb->data;st
ructtimeval*next_update=arg;staticstructtimevalelapsed;//elapsedtimesincekeepali
vestaticstructtimevalka={0};//peer->v_keepaliveasatimevalstaticstructtimevaldiff
;//ka-elapsedstaticstructtimevaltolerance={0,100000};/*calculateelapsedtimesince
lastkeepalive*/monotime_since(&pkat->last,&elapsed);/*calculatedifferencebetween
elapsedtimeandconfiguredtime*/ka.tv_sec=pkat->peer->v_keepalive;timersub(&ka,&el
apsed,&diff);intsend_keepalive=elapsed.tv_sec>=ka.tv_sec||timercmp(&diff,&tolera
nce,<);if(send_keepalive){if(bgp_debug_neighbor_events(pkat->peer))zlog_debug("%
s[FSM]Timer(keepalivetimerexpire)",pkat->peer->host);bgp_keepalive_send(pkat->pe
er);monotime(&pkat->last);memset(&elapsed,0x00,sizeof(structtimeval));diff=ka;}/
*ifcalculatednextupdateforthispeer<currentdelay,useit*/if(next_update->tv_sec<0|
|timercmp(&diff,next_update,<))*next_update=diff;}staticintpeer_hash_cmp(constvo
id*f,constvoid*s){conststructpkat*p1=f;conststructpkat*p2=s;returnp1->peer==p2->
peer;}staticunsignedintpeer_hash_key(void*arg){structpkat*pkat=arg;return(uintpt
r_t)pkat->peer;}/*Cleanuphandler/deinitializer.*/staticvoidbgp_keepalives_finish
(void*arg){if(peerhash){hash_clean(peerhash,pkat_del);hash_free(peerhash);}peerh
ash=NULL;pthread_mutex_unlock(peerhash_mtx);pthread_mutex_destroy(peerhash_mtx);
pthread_cond_destroy(peerhash_cond);XFREE(MTYPE_TMP,peerhash_mtx);XFREE(MTYPE_TM
P,peerhash_cond);}/**Entryfunctionforpeerkeepalivegenerationpthread.*/void*bgp_k
eepalives_start(void*arg){structfrr_pthread*fpt=arg;fpt->master->owner=pthread_s
elf();structtimevalcurrtime={0,0};structtimevalaftertime={0,0};structtimevalnext
_update={0,0};structtimespecnext_update_ts={0,0};peerhash_mtx=XCALLOC(MTYPE_TMP,
sizeof(pthread_mutex_t));peerhash_cond=XCALLOC(MTYPE_TMP,sizeof(pthread_cond_t))
;/*initializemutex*/pthread_mutex_init(peerhash_mtx,NULL);/*usemonotonicclockwit
hconditionvariable*/pthread_condattr_tattrs;pthread_condattr_init(&attrs);pthrea
d_condattr_setclock(&attrs,CLOCK_MONOTONIC);pthread_cond_init(peerhash_cond,&att
rs);pthread_condattr_destroy(&attrs);/*initializepeerhashtable*/peerhash=hash_cr
eate_size(2048,peer_hash_key,peer_hash_cmp,NULL);pthread_mutex_lock(peerhash_mtx
);/*registercleanuphandler*/pthread_cleanup_push(&bgp_keepalives_finish,NULL);/*
notifyanybodywaitingonusthatwearedonestartingup*/frr_pthread_notify_running(fpt)
;while(atomic_load_explicit(&fpt->running,memory_order_relaxed)){if(peerhash->co
unt>0)pthread_cond_timedwait(peerhash_cond,peerhash_mtx,&next_update_ts);elsewhi
le(peerhash->count==0&&atomic_load_explicit(&fpt->running,memory_order_relaxed))
pthread_cond_wait(peerhash_cond,peerhash_mtx);monotime(&currtime);next_update.tv
_sec=-1;hash_iterate(peerhash,peer_process,&next_update);if(next_update.tv_sec==
-1)memset(&next_update,0x00,sizeof(next_update));monotime_since(&currtime,&after
time);timeradd(&currtime,&next_update,&next_update);TIMEVAL_TO_TIMESPEC(&next_up
date,&next_update_ts);}/*cleanup*/pthread_cleanup_pop(1);returnNULL;}/*---thread
externalfunctions-------------------------------------------*/voidbgp_keepalives
_on(structpeer*peer){if(CHECK_FLAG(peer->thread_flags,PEER_THREAD_KEEPALIVES_ON)
)return;structfrr_pthread*fpt=frr_pthread_get(PTHREAD_KEEPALIVES);assert(fpt->ru
nning);/*placeholderbucketdatatouseforfastkeylookups*/staticstructpkatholder={0}
;if(!peerhash_mtx){zlog_warn("%s:callbgp_keepalives_init()first",__func__);retur
n;}pthread_mutex_lock(peerhash_mtx);{holder.peer=peer;if(!hash_lookup(peerhash,&
holder)){structpkat*pkat=pkat_new(peer);hash_get(peerhash,pkat,hash_alloc_intern
);peer_lock(peer);}SET_FLAG(peer->thread_flags,PEER_THREAD_KEEPALIVES_ON);}pthre
ad_mutex_unlock(peerhash_mtx);bgp_keepalives_wake();}voidbgp_keepalives_off(stru
ctpeer*peer){if(!CHECK_FLAG(peer->thread_flags,PEER_THREAD_KEEPALIVES_ON))return
;structfrr_pthread*fpt=frr_pthread_get(PTHREAD_KEEPALIVES);assert(fpt->running);
/*placeholderbucketdatatouseforfastkeylookups*/staticstructpkatholder={0};if(!pe
erhash_mtx){zlog_warn("%s:callbgp_keepalives_init()first",__func__);return;}pthr
ead_mutex_lock(peerhash_mtx);{holder.peer=peer;structpkat*res=hash_release(peerh
ash,&holder);if(res){pkat_del(res);peer_unlock(peer);}UNSET_FLAG(peer->thread_fl
ags,PEER_THREAD_KEEPALIVES_ON);}pthread_mutex_unlock(peerhash_mtx);}voidbgp_keep
alives_wake(){pthread_mutex_lock(peerhash_mtx);{pthread_cond_signal(peerhash_con
d);}pthread_mutex_unlock(peerhash_mtx);}intbgp_keepalives_stop(structfrr_pthread
*fpt,void**result){assert(fpt->running);atomic_store_explicit(&fpt->running,fals
e,memory_order_relaxed);bgp_keepalives_wake();pthread_join(fpt->thread,result);r
eturn0;}