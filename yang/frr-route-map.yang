module frr-route-map {
  yang-version 1.1;
  namespace "http://frrouting.org/yang/route-map";
  prefix frr-route-map;

  import ietf-inet-types {
    prefix inet;
  }
  import frr-filter {
    prefix filter;
  }

  organization "FRRouting";
  contact
    "FRR Users List:       <mailto:frog@lists.frrouting.org>
     FRR Development List: <mailto:dev@lists.frrouting.org>";
  description "This module defines route map settings";

  revision 2019-07-01 {
    description "Initial revision";
  }

  /*
   * Types.
   */
  typedef route-map-sequence {
    description "Route map valid sequence numbers";
    type uint16 {
      range "1..65535";
    }
  }

  typedef route-map-name {
    description "Route map name format";
    type string;
  }

  identity rmap-match-type {
    description "Base route-map match-condition";
  }
  identity interface {
    base rmap-match-type;
    description "Match interface";
  }
  identity ipv4-address-list {
    base rmap-match-type;
    description "Match an IPv4 access-list";
  }
  identity ipv4-prefix-list {
    base rmap-match-type;
    description "Match an IPv4 prefix-list";
  }
  identity ipv4-next-hop-list {
    base rmap-match-type;
    description "Match an IPv4 next-hop";
  }
  identity ipv4-next-hop-prefix-list {
    base rmap-match-type;
    description "Match an IPv4 next-hop prefix list";
  }
  identity ipv4-next-hop-type {
    base rmap-match-type;
    description "Match an IPv4 next-hop type";
  }
  identity ipv6-address-list {
    base rmap-match-type;
    description "Match an IPv6 access-list";
  }
  identity ipv6-prefix-list {
    base rmap-match-type;
    description "Match an IPv6 prefix-list";
  }
  identity ipv6-next-hop-type {
    base rmap-match-type;
    description "Match an IPv6 next-hop type";
  }
  identity match-metric {
    base rmap-match-type;
    description "Match a route metric";
  }
  identity match-tag {
    base rmap-match-type;
    description "Match a route tag";
  }

  identity rmap-set-type {
    description "Base route-map set-action";
  }
  identity ipv4-next-hop {
    base rmap-set-type;
    description "Set IPv4 address of the next hop";
  }
  identity ipv6-next-hop {
    base rmap-set-type;
    description "Set IPv6 address of the next hop";
  }
  identity set-metric {
    base rmap-set-type;
    description "Set prefix/route metric";
  }
  identity set-tag {
    base rmap-set-type;
    description "Set tag";
  }

  /*
   * Operational data.
   */
  container lib {
    list route-map {
      description "Route map instance";

      key "name";

      leaf name {
        description "Route map instance name";
        type route-map-name;
      }

      list entry {
        description "Route map entry";

        key "sequence";

        leaf sequence {
          description
            "Route map instance priority (low number means higher priority)";
          type route-map-sequence;
        }

        leaf description {
          description "Route map description";
          type string;
        }

        leaf action {
          description
            "Route map actions: permit (executes action), deny (quits evaluation)";
          mandatory true;
          type enumeration {
            enum permit {
              description
                "Executes configured action and permits the prefix/route
                 if the conditions matched. An alternative exit action can
                 be configured to continue processing the route map list
                 or jump to process another route map.";
              value 0;
            }
            enum deny {
              description
                "If all conditions are met the prefix/route is denied and
                 route map processing stops.";
              value 1;
            }
          }
        }

        leaf call {
          description
            "Call another route map before calling `exit-policy`. If the
             called route map returns deny then this route map will also
             return deny";
          type route-map-name;
        }

        leaf exit-policy {
          description "What do to after route map successful match, set and call";
          type enumeration {
            enum permit-or-deny {
              description "End route map evaluation and return";
              value 0;
            }
            enum next {
              description
                "Proceed evaluating next route map entry per sequence";
              value 1;
            }
            enum goto {
              description
                "Go to route map entry with the provided sequence number";
              value 2;
            }
          }
          default "permit-or-deny";
        }

        leaf goto-value {
          when "../exit-policy = 'goto'";
          description
            "Sequence number to jump (when using `goto` exit policy)";
          mandatory true;
          type route-map-sequence;
        }

        list match-condition {
          description "Route map match conditions";

          key "condition";

          leaf condition {
            description "Match condition";
            type identityref {
              base rmap-match-type;
            }
          }
          uses rmap-match-condition;
        }

        list set-action {
          description "Route map set actions";

          key "action";

          leaf action {
            description "Action to do when the route map matches";
            type identityref {
              base rmap-set-type;
            }
          }
          uses rmap-set-action;
        }
      }
    }
  }

  grouping rmap-match-condition {
    container rmap-match-condition {
      choice match-condition {
        description
          "Value to match (interpretation depends on condition type)";
        case interface {
          when "derived-from-or-self(../condition, 'interface')";
          leaf interface {
            type string;
          }
        }
        case access-list-num {
          when "derived-from-or-self(../condition, 'ipv4-address-list') or
                derived-from-or-self(../condition, 'ipv4-next-hop-list')";
          leaf access-list-num {
            type filter:access-list-standard;
          }
        }
        case access-list-num-extended {
          when "derived-from-or-self(../condition, 'ipv4-address-list') or
                derived-from-or-self(../condition, 'ipv4-next-hop-list')";
          leaf access-list-num-extended {
            type filter:access-list-extended;
          }
        }
        case list-name {
          when "derived-from-or-self(../condition, 'ipv4-address-list') or
                derived-from-or-self(../condition, 'ipv4-prefix-list') or
                derived-from-or-self(../condition, 'ipv4-next-hop-list') or
                derived-from-or-self(../condition, 'ipv4-next-hop-prefix-list') or
                derived-from-or-self(../condition, 'ipv6-address-list') or
                derived-from-or-self(../condition, 'ipv6-prefix-list')";
          leaf list-name {
            type filter:access-list-name;
          }
        }
        case ipv4-next-hop-type {
          when "derived-from-or-self(../condition, 'ipv4-next-hop-type')";
          leaf ipv4-next-hop-type {
            type enumeration {
              enum blackhole {
                value 0;
              }
            }
          }
        }
        case ipv6-next-hop-type {
          when "derived-from-or-self(../condition, 'ipv6-next-hop-type')";
          leaf ipv6-next-hop-type {
            type enumeration {
              enum blackhole {
                value 0;
              }
            }
          }
        }
        case match-metric {
          when "derived-from-or-self(../condition, 'match-metric')";
          leaf metric {
            type uint32 {
              range "1..4294967295";
            }
          }
        }
        case match-tag {
          when "derived-from-or-self(../condition, 'match-tag')";
          leaf tag {
            type uint32 {
              range "1..4294967295";
            }
          }
        }
      }
    }
  }
  grouping rmap-set-action {
    container rmap-set-action {
      choice set-action {
        description
          "Value to set (interpretation depends on action-type)";
        case ipv4-address {
          when "derived-from-or-self(../action, 'ipv4-next-hop')";
          leaf ipv4-address {
            description "IPv4 address";
            type inet:ipv4-address;
          }
        }
        case ipv6-address {
          when "derived-from-or-self(../action, 'ipv6-next-hop')";
          leaf ipv6-address {
            description "IPv6 address";
            type inet:ipv6-address;
          }
        }
        case set-metric {
          when "derived-from-or-self(../action, 'set-metric')";
          choice metric-value {
            description "Metric to set or use";
            case value {
              leaf value {
                description "Use the following metric value";
                type uint32 {
                  range "0..4294967295";
                }
              }
            }
            case add-metric {
              leaf add-metric {
                description "Add unit to metric";
                type boolean;
              }
            }
            case subtract-metric {
              leaf subtract-metric {
                description "Subtract unit from metric";
                type boolean;
              }
            }
            case use-round-trip-time {
              leaf use-round-trip-time {
                description "Use the round trip time as metric";
                type boolean;
              }
            }
            case add-round-trip-time {
              leaf add-round-trip-time {
                description "Add round trip time to metric";
                type boolean;
              }
            }
            case subtract-round-trip-time {
              leaf subtract-round-trip-time {
                description "Subtract round trip time to metric";
                type boolean;
              }
            }
          }
        }
        case set-tag {
          when "derived-from-or-self(../action, 'set-tag')";
          leaf tag {
            description "Tag value";
            type uint32 {
              range "0..4294967295";
            }
          }
        }
      }
    }
  }
}
