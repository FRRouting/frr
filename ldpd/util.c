/*$OpenBSD$*//**Copyright(c)2015RenatoWestphal<renato@openbsd.org>*Copyright(c)2
012AlexanderBluhm<bluhm@openbsd.org>*Copyright(c)2004EsbenNorby<norby@openbsd.or
g>*Copyright(c)2003,2004HenningBrauer<henning@openbsd.org>**Permissiontouse,copy
,modify,anddistributethissoftwareforany*purposewithorwithoutfeeisherebygranted,p
rovidedthattheabove*copyrightnoticeandthispermissionnoticeappearinallcopies.**TH
ESOFTWAREISPROVIDED"ASIS"ANDTHEAUTHORDISCLAIMSALLWARRANTIES*WITHREGARDTOTHISSOFT
WAREINCLUDINGALLIMPLIEDWARRANTIESOF*MERCHANTABILITYANDFITNESS.INNOEVENTSHALLTHEA
UTHORBELIABLEFOR*ANYSPECIAL,DIRECT,INDIRECT,ORCONSEQUENTIALDAMAGESORANYDAMAGES*W
HATSOEVERRESULTINGFROMLOSSOFUSE,DATAORPROFITS,WHETHERINAN*ACTIONOFCONTRACT,NEGLI
GENCEOROTHERTORTIOUSACTION,ARISINGOUTOF*ORINCONNECTIONWITHTHEUSEORPERFORMANCEOFT
HISSOFTWARE.*/#include<zebra.h>#include"ldpd.h"#include"log.h"uint8_tmask2prefix
len(in_addr_tina){if(ina==0)return(0);elsereturn(33-ffs(ntohl(ina)));}uint8_tmas
k2prefixlen6(structsockaddr_in6*sa_in6){uint8_tl=0,*ap,*ep;/**sin6_lenisthesizeo
fthesockaddrsosubstracttheoffsetof*thepossiblytruncatedsin6_addrstruct.*/ap=(uin
t8_t*)&sa_in6->sin6_addr;ep=(uint8_t*)sa_in6+sockaddr_len((structsockaddr*)sa_in
6);for(;ap<ep;ap++){/*this"beauty"isadoptedfromsbin/route/show.c...*/switch(*ap)
{case0xff:l+=8;break;case0xfe:l+=7;return(l);case0xfc:l+=6;return(l);case0xf8:l+
=5;return(l);case0xf0:l+=4;return(l);case0xe0:l+=3;return(l);case0xc0:l+=2;retur
n(l);case0x80:l+=1;return(l);case0x00:return(l);default:fatalx("noncontiguousine
t6netmask");}}return(l);}in_addr_tprefixlen2mask(uint8_tprefixlen){if(prefixlen=
=0)return(0);return(htonl(0xffffffff<<(32-prefixlen)));}structin6_addr*prefixlen
2mask6(uint8_tprefixlen){staticstructin6_addrmask;inti;memset(&mask,0,sizeof(mas
k));for(i=0;i<prefixlen/8;i++)mask.s6_addr[i]=0xff;i=prefixlen%8;if(i)mask.s6_ad
dr[prefixlen/8]=0xff00>>i;return(&mask);}voidldp_applymask(intaf,unionldpd_addr*
dest,constunionldpd_addr*src,intprefixlen){structin6_addrmask;inti;switch(af){ca
seAF_INET:dest->v4.s_addr=src->v4.s_addr&prefixlen2mask(prefixlen);break;caseAF_
INET6:memset(&mask,0,sizeof(mask));for(i=0;i<prefixlen/8;i++)mask.s6_addr[i]=0xf
f;i=prefixlen%8;if(i)mask.s6_addr[prefixlen/8]=0xff00>>i;for(i=0;i<16;i++)dest->
v6.s6_addr[i]=src->v6.s6_addr[i]&mask.s6_addr[i];break;default:fatalx("ldp_apply
mask:unknownaf");}}intldp_addrcmp(intaf,constunionldpd_addr*a,constunionldpd_add
r*b){switch(af){caseAF_INET:if(a->v4.s_addr==b->v4.s_addr)return(0);return((ntoh
l(a->v4.s_addr)>ntohl(b->v4.s_addr))?1:-1);caseAF_INET6:return(memcmp(&a->v6,&b-
>v6,sizeof(structin6_addr)));default:fatalx("ldp_addrcmp:unknownaf");}}intldp_ad
drisset(intaf,constunionldpd_addr*addr){switch(af){caseAF_UNSPEC:return(0);caseA
F_INET:if(addr->v4.s_addr!=INADDR_ANY)return(1);break;caseAF_INET6:if(!IN6_IS_AD
DR_UNSPECIFIED(&addr->v6))return(1);break;default:fatalx("ldp_addrisset:unknowna
f");}return(0);}intldp_prefixcmp(intaf,constunionldpd_addr*a,constunionldpd_addr
*b,uint8_tprefixlen){in_addr_tmask,aa,ba;inti;uint8_tm;switch(af){caseAF_INET:if
(prefixlen==0)return(0);if(prefixlen>32)fatalx("ldp_prefixcmp:badIPv4prefixlen")
;mask=htonl(prefixlen2mask(prefixlen));aa=htonl(a->v4.s_addr)&mask;ba=htonl(b->v
4.s_addr)&mask;return(aa-ba);caseAF_INET6:if(prefixlen==0)return(0);if(prefixlen
>128)fatalx("ldp_prefixcmp:badIPv6prefixlen");for(i=0;i<prefixlen/8;i++)if(a->v6
.s6_addr[i]!=b->v6.s6_addr[i])return(a->v6.s6_addr[i]-b->v6.s6_addr[i]);i=prefix
len%8;if(i){m=0xff00>>i;if((a->v6.s6_addr[prefixlen/8]&m)!=(b->v6.s6_addr[prefix
len/8]&m))return((a->v6.s6_addr[prefixlen/8]&m)-(b->v6.s6_addr[prefixlen/8]&m));
}return(0);default:fatalx("ldp_prefixcmp:unknownaf");}return(-1);}intbad_addr_v4
(structin_addraddr){uint32_ta=ntohl(addr.s_addr);if(((a>>IN_CLASSA_NSHIFT)==0)||
((a>>IN_CLASSA_NSHIFT)==IN_LOOPBACKNET)||IN_MULTICAST(a)||IN_BADCLASS(a))return(
1);return(0);}intbad_addr_v6(structin6_addr*addr){if(IN6_IS_ADDR_UNSPECIFIED(add
r)||IN6_IS_ADDR_LOOPBACK(addr)||IN6_IS_ADDR_MULTICAST(addr)||IN6_IS_ADDR_SITELOC
AL(addr)||IN6_IS_ADDR_V4MAPPED(addr)||IN6_IS_ADDR_V4COMPAT(addr))return(1);retur
n(0);}intbad_addr(intaf,unionldpd_addr*addr){switch(af){caseAF_INET:return(bad_a
ddr_v4(addr->v4));caseAF_INET6:return(bad_addr_v6(&addr->v6));default:fatalx("ba
d_addr:unknownaf");}}voidembedscope(structsockaddr_in6*sin6){uint16_ttmp16;if(IN
6_IS_SCOPE_EMBED(&sin6->sin6_addr)){memcpy(&tmp16,&sin6->sin6_addr.s6_addr[2],si
zeof(tmp16));if(tmp16!=0){log_warnx("%s:address%salreadyhasembededscope%u",__fun
c__,log_sockaddr(sin6),ntohs(tmp16));}tmp16=htons(sin6->sin6_scope_id);memcpy(&s
in6->sin6_addr.s6_addr[2],&tmp16,sizeof(tmp16));sin6->sin6_scope_id=0;}}voidreco
verscope(structsockaddr_in6*sin6){uint16_ttmp16;if(sin6->sin6_scope_id!=0)log_wa
rnx("%s:address%salreadyhasscopeid%u",__func__,log_sockaddr(sin6),sin6->sin6_sco
pe_id);if(IN6_IS_SCOPE_EMBED(&sin6->sin6_addr)){memcpy(&tmp16,&sin6->sin6_addr.s
6_addr[2],sizeof(tmp16));sin6->sin6_scope_id=ntohs(tmp16);sin6->sin6_addr.s6_add
r[2]=0;sin6->sin6_addr.s6_addr[3]=0;}}voidaddscope(structsockaddr_in6*sin6,uint3
2_tid){if(sin6->sin6_scope_id!=0)log_warnx("%s:address%salreadyhasscopeid%u",__f
unc__,log_sockaddr(sin6),sin6->sin6_scope_id);if(IN6_IS_SCOPE_EMBED(&sin6->sin6_
addr))sin6->sin6_scope_id=id;}voidclearscope(structin6_addr*in6){if(IN6_IS_SCOPE
_EMBED(in6)){in6->s6_addr[2]=0;in6->s6_addr[3]=0;}}structsockaddr*addr2sa(intaf,
unionldpd_addr*addr,uint16_tport){staticstructsockaddr_storagess;structsockaddr_
in*sa_in=(structsockaddr_in*)&ss;structsockaddr_in6*sa_in6=(structsockaddr_in6*)
&ss;memset(&ss,0,sizeof(ss));switch(af){caseAF_INET:sa_in->sin_family=AF_INET;#i
fdefHAVE_STRUCT_SOCKADDR_IN_SIN_LENsa_in->sin_len=sizeof(structsockaddr_in);#end
ifsa_in->sin_addr=addr->v4;sa_in->sin_port=htons(port);break;caseAF_INET6:sa_in6
->sin6_family=AF_INET6;#ifdefHAVE_STRUCT_SOCKADDR_IN_SIN_LENsa_in6->sin6_len=siz
eof(structsockaddr_in6);#endifsa_in6->sin6_addr=addr->v6;sa_in6->sin6_port=htons
(port);break;default:fatalx("addr2sa:unknownaf");}return((structsockaddr*)&ss);}
voidsa2addr(structsockaddr*sa,int*af,unionldpd_addr*addr,in_port_t*port){structs
ockaddr_in*sa_in=(structsockaddr_in*)sa;structsockaddr_in6*sa_in6=(structsockadd
r_in6*)sa;if(addr)memset(addr,0,sizeof(*addr));switch(sa->sa_family){caseAF_INET
:if(af)*af=AF_INET;if(addr)addr->v4=sa_in->sin_addr;if(port)*port=sa_in->sin_por
t;break;caseAF_INET6:if(af)*af=AF_INET6;if(addr)addr->v6=sa_in6->sin6_addr;if(po
rt)*port=sa_in6->sin6_port;break;default:fatalx("sa2addr:unknownaf");}}socklen_t
sockaddr_len(structsockaddr*sa){#ifdefHAVE_STRUCT_SOCKADDR_IN_SIN_LENreturn(sa->
sa_len);#elseswitch(sa->sa_family){caseAF_INET:return(sizeof(structsockaddr_in))
;caseAF_INET6:return(sizeof(structsockaddr_in6));default:fatalx("sockaddr_len:un
knownaf");}#endif}