#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2018-2021  David Lamparter for NetDEF, Inc.
"""
Topotato topology/config fixtures
"""

import sys
import functools

from .parse import Topology
from .toponom import Network
from .network import TopotatoNetwork
from .frr import FRRRouterNS


# this is * imported for all tests
__all__ = [
    "mkfixture",
    "mkfixture_pytest",
    "topology_fixture",
    "AutoFixture",
]


def mkfixture_pytest(*args, **kwargs):
    """
    wrap pytest.fixture to allow loading test classes without pulling in
    all of pytest.  Intended to be overridden/replaced when writing a
    standalone script that imports some test class.
    """
    # pylint: disable=import-outside-toplevel
    from pytest import fixture

    return fixture(*args, **kwargs)


mkfixture = mkfixture_pytest


def topology_fixture():
    """
    Fixture to use for defining a test topology

    The topology is immediately instantiated from the docstring, and only one
    instance is created.  The function can modify the result topology (e.g.
    to change IP addresses) through its function parameter.
    """

    def getwrap(fn):
        topo = Topology(fn.__doc__)

        net = Network()
        net.load_parse(topo)

        # partial() used here so fnwrap() doesn't have the topo arg in its
        # function signature.  (would otherwise be visible on
        # inspect.signature() which pytest uses for fixtures)

        fnwrap = functools.partial(fn, net)
        fnwrap()

        net.auto_num()
        net.auto_ifnames()
        net.auto_ip4()
        net.auto_ip6()

        @functools.wraps(fnwrap)
        def wrap():
            return net

        wrap.__module__ = fn.__module__
        wrap.__doc__ = fn.__doc__

        fixture = mkfixture(scope="module")(wrap)
        fixture.net = net
        return fixture

    return getwrap


class AutoFixture:
    @classmethod
    def __init_subclass__(cls, /, topo=None, configs=None, setup=None, **kwargs):
        super().__init_subclass__(**kwargs)
        if setup is not None:
            cls._init_setup(setup)

        if not (topo and configs):
            if topo or configs:
                raise RuntimeError(
                    f"{cls.__name__}: topo= and configs= must be used together"
                )
            return

        # pylint: disable=import-outside-toplevel
        from _pytest import fixtures

        clsmod = sys.modules[cls.__module__]
        configs = configs.prepare()

        orig_topo = topo
        while hasattr(orig_topo, "__wrapped__") or hasattr(orig_topo, "func"):
            orig_topo = getattr(orig_topo, "__wrapped__", orig_topo)
            orig_topo = getattr(orig_topo, "func", orig_topo)
        topo_name = orig_topo.__name__

        cfix_name = f"{cls.__name__.lower()}_configs"

        def auto_config(request):
            topo_inst = request.getfixturevalue(topo_name)
            config = configs(topo_inst, request.session.frr)
            config.generate()
            return config

        auto_config.__name__ = cfix_name
        auto_config.__module__ = cls.__module__
        auto_config.__doc__ = (
            f"autogenerated config fixture for {cls.__module__}.{cls.__name__}"
        )

        auto_cfix = fixtures.fixture(scope="module", name=cfix_name)(auto_config)
        auto_cfix.net = topo.net
        auto_cfix.cfgclass = configs
        setattr(clsmod, cfix_name, auto_cfix)

        ifix_name = f"{cls.__name__.lower()}_instance"

        # pylint: disable=abstract-class-instantiated
        @staticmethod
        def auto_instance(request):
            cfg_inst = request.getfixturevalue(cfix_name)
            net_inst = TopotatoNetwork(cfg_inst.topology)

            for rtrname in cfg_inst.topology.routers.keys():
                net_inst.router_factories[rtrname] = lambda name: FRRRouterNS(
                    net_inst, name, cfg_inst
                )
            return net_inst.prepare()

        auto_instance.__name__ = ifix_name
        auto_instance.__module__ = cls.__module__
        auto_instance.__doc__ = (
            f"autogenerated instance fixture for {cls.__module__}.{cls.__name__}"
        )

        auto_ifix = fixtures.fixture(scope="class", name=ifix_name)(auto_instance)
        auto_ifix.testenv = True
        auto_ifix.net = topo.net
        auto_ifix.configs = auto_cfix

        # TODO: detangle this
        # setattr(clsmod, ifix_name, auto_ifix)
        setattr(cls, ifix_name, auto_ifix)

        cls.instancefixturename = ifix_name

    @classmethod
    def _init_setup(cls, setup):
        # pylint: disable=import-outside-toplevel
        from _pytest import fixtures

        ifix_name = f"{cls.__name__.lower()}_instance"

        orig_topo = setup.topo
        while hasattr(orig_topo, "__wrapped__") or hasattr(orig_topo, "func"):
            orig_topo = getattr(orig_topo, "__wrapped__", orig_topo)
            orig_topo = getattr(orig_topo, "func", orig_topo)
        topo_name = orig_topo.__name__

        @staticmethod
        def auto_instance(request):
            topo = request.getfixturevalue(topo_name)
            net_inst = setup(topo)

            for rtrname in topo.routers.keys():
                net_inst.router_factories[rtrname] = lambda name: setup.__annotations__[
                    name
                ](net_inst, name, request.session.frr)
            return net_inst.prepare()

        auto_instance.__name__ = ifix_name
        auto_instance.__module__ = cls.__module__
        auto_instance.__doc__ = (
            f"autogenerated instance fixture for {cls.__module__}.{cls.__name__}"
        )

        auto_ifix = fixtures.fixture(scope="class", name=ifix_name)(auto_instance)
        auto_ifix.testenv = True
        auto_ifix.net = setup.topo.net

        # TODO: detangle this
        # setattr(clsmod, ifix_name, auto_ifix)
        setattr(cls, ifix_name, auto_ifix)

        cls.instancefixturename = ifix_name
